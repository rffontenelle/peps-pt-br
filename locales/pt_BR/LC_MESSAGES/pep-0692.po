# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-28 20:07+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.11.0\n"

#: ../pep-0692.rst
msgid "Author"
msgstr "Autor"

#: ../pep-0692.rst:3
msgid "Franek Magiera <framagie@gmail.com>"
msgstr ""

#: ../pep-0692.rst
msgid "Sponsor"
msgstr ""

#: ../pep-0692.rst:4
msgid "Jelle Zijlstra <jelle.zijlstra@gmail.com>"
msgstr ""

#: ../pep-0692.rst
msgid "Discussions-To"
msgstr ""

#: ../pep-0692.rst:5
msgid ""
"https://discuss.python.org/t/pep-692-using-typeddict-for-more-precise-kwargs-"
"typing/17314"
msgstr ""

#: ../pep-0692.rst
msgid "Status"
msgstr "Status"

#: ../pep-0692.rst:6
msgid "Draft"
msgstr ""

#: ../pep-0692.rst
msgid "Type"
msgstr "Tipo"

#: ../pep-0692.rst:7
msgid "Standards Track"
msgstr ""

#: ../pep-0692.rst
msgid "Topic"
msgstr ""

#: ../pep-0692.rst:8
msgid "Typing"
msgstr ""

#: ../pep-0692.rst
msgid "Created"
msgstr "Criada em"

#: ../pep-0692.rst:10
msgid "29-May-2022"
msgstr ""

#: ../pep-0692.rst
msgid "Python-Version"
msgstr ""

#: ../pep-0692.rst:11
msgid "3.12"
msgstr ""

#: ../pep-0692.rst
msgid "Post-History"
msgstr "Pós-história"

#: ../pep-0692.rst:12
msgid ""
"`29-May-2022 <https://mail.python.org/archives/list/typing-sig@python.org/"
"thread/U42MJE6QZYWPVIFHJIGIT7OE52ZGIQV3/>`__, `12-Jul-2022 <https://mail."
"python.org/archives/list/python-dev@python.org/thread/"
"PLCNW2XR4OOKAKHEZQM7R2AYVYUXPZGW/>`__, `12-Jul-2022 <https://discuss.python."
"org/t/pep-692-using-typeddict-for-more-precise-kwargs-typing/17314>`__,"
msgstr ""

#: ../pep-0692.rst:18
msgid "Abstract"
msgstr ""

#: ../pep-0692.rst:20
msgid ""
"Currently ``**kwargs`` can be type hinted as long as all of the keyword "
"arguments specified by them are of the same type. However, that behaviour "
"can be very limiting. Therefore, in this PEP we propose a new way to enable "
"more precise ``**kwargs`` typing. The new approach revolves around using "
"``TypedDict`` to type ``**kwargs`` that comprise keyword arguments of "
"different types. It also involves introducing a grammar change and a new "
"dunder ``__typing_unpack__``."
msgstr ""

#: ../pep-0692.rst:31
msgid "Motivation"
msgstr ""

#: ../pep-0692.rst:33
msgid ""
"Currently annotating ``**kwargs`` with a type ``T`` means that the "
"``kwargs`` type is in fact ``dict[str, T]``. For example::"
msgstr ""

#: ../pep-0692.rst:38
msgid ""
"means that all keyword arguments in ``foo`` are strings (i.e., ``kwargs`` is "
"of type ``dict[str, str]``). This behaviour limits the ability to type "
"annotate ``**kwargs`` only to the cases where all of them are of the same "
"type. However, it is often the case that keyword arguments conveyed by "
"``**kwargs`` have different types that are dependent on the keyword's name. "
"In those cases type annotating ``**kwargs`` is not possible. This is "
"especially a problem for already existing codebases where the need of "
"refactoring the code in order to introduce proper type annotations may be "
"considered not worth the effort. This in turn prevents the project from "
"getting all of the benefits that type hinting can provide."
msgstr ""

#: ../pep-0692.rst:49
msgid ""
"Moreover, ``**kwargs`` can be used to reduce the amount of code needed in "
"cases when there is a top-level function that is a part of a public API and "
"it calls a bunch of helper functions, all of which expect the same keyword "
"arguments. Unfortunately, if those helper functions were to use "
"``**kwargs``, there is no way to properly type hint them if the keyword "
"arguments they expect are of different types. In addition, even if the "
"keyword arguments are of the same type, there is no way to check whether the "
"function is being called with keyword names that it actually expects."
msgstr ""

#: ../pep-0692.rst:58
msgid ""
"As described in the :ref:`Intended Usage <pep-692-intended-usage>` section, "
"using ``**kwargs`` is not always the best tool for the job. Despite that, it "
"is still a widely used pattern. As a consequence, there has been a lot of "
"discussion around supporting more precise ``**kwargs`` typing and it became "
"a feature that would be valuable for a large part of the Python community. "
"This is best illustrated by the `mypy GitHub issue 4441 <mypyIssue4441_>`__ "
"which contains a lot of real world cases that could benefit from this "
"propsal."
msgstr ""

#: ../pep-0692.rst:66
msgid ""
"One more use case worth mentioning for which ``**kwargs`` are also "
"convenient, is when a function should accommodate optional keyword-only "
"arguments that don't have default values. A need for a pattern like that can "
"arise when values that are usually used as defaults to indicate no user "
"input, such as ``None``, can be passed in by a user and should result in a "
"valid, non-default behavior. For example, this issue `came up "
"<httpxIssue1384_>`__ in the popular ``httpx`` library."
msgstr ""

#: ../pep-0692.rst:74
msgid "Rationale"
msgstr ""

#: ../pep-0692.rst:76
msgid ""
":pep:`589` introduced the ``TypedDict`` type constructor that supports "
"dictionary types consisting of string keys and values of potentially "
"different types. A function's keyword arguments represented by a formal "
"parameter that begins with double asterisk, such as ``**kwargs``, are "
"received as a dictionary. Additionally, such functions are often called "
"using unpacked dictionaries to provide keyword arguments. This makes "
"``TypedDict`` a perfect candidate to be used for more precise ``**kwargs`` "
"typing. In addition, with ``TypedDict`` keyword names can be taken into "
"account during static type analysis. However, specifying ``**kwargs`` type "
"with a ``TypedDict`` means, as mentioned earlier, that each keyword argument "
"specified by ``**kwargs`` is a ``TypedDict`` itself. For instance::"
msgstr ""

#: ../pep-0692.rst:94
msgid ""
"means that each keyword argument in ``foo`` is itself a ``Movie`` dictionary "
"that has a ``name`` key with a string type value and a ``year`` key with an "
"integer type value. Therefore, in order to support specifying ``kwargs`` "
"type as a ``TypedDict`` without breaking current behaviour, a new syntax has "
"to be introduced."
msgstr ""

#: ../pep-0692.rst:101
msgid "Specification"
msgstr ""

#: ../pep-0692.rst:103
msgid ""
"To support the aforementioned use case we propose to use the double asterisk "
"syntax inside of the type annotation. The required grammar change is "
"discussed in more detail in section `Grammar Changes`_. Continuing the "
"previous example::"
msgstr ""

#: ../pep-0692.rst:109
msgid ""
"would mean that the ``**kwargs`` comprise two keyword arguments specified by "
"``Movie`` (i.e. a ``name`` keyword of type ``str`` and a ``year`` keyword of "
"type ``int``). This indicates that the function should be called as follows::"
msgstr ""

#: ../pep-0692.rst:118
msgid ""
"Inside the function itself, the type checkers should treat the ``kwargs`` "
"parameter as a ``TypedDict``::"
msgstr ""

#: ../pep-0692.rst:125
msgid ""
"Using the new annotation will not have any runtime effect - it should only "
"be taken into account by type checkers. Any mention of errors in the "
"following sections relates to type checker errors."
msgstr ""

#: ../pep-0692.rst:130
msgid "Function calls with standard dictionaries"
msgstr ""

#: ../pep-0692.rst:132
msgid ""
"Calling a function that has ``**kwargs`` typed using the ``**kwargs: "
"**Movie`` syntax with a dictionary of type ``dict[str, object]`` must "
"generate a type checker error. On the other hand, the behaviour for "
"functions using standard, untyped dictionaries can depend on the type "
"checker. For example::"
msgstr ""

#: ../pep-0692.rst:149
msgid "Keyword collisions"
msgstr ""

#: ../pep-0692.rst:151
msgid ""
"A ``TypedDict`` that is used to type ``**kwargs`` could potentially contain "
"keys that are already defined in the function's signature. If the duplicate "
"name is a standard parameter, an error should be reported by type checkers. "
"If the duplicate name is a positional-only parameter, no errors should be "
"generated. For example::"
msgstr ""

#: ../pep-0692.rst:167
msgid "Required and non-required keys"
msgstr ""

#: ../pep-0692.rst:169
msgid ""
"By default all keys in a ``TypedDict`` are required. This behaviour can be "
"overridden by setting the dictionary's ``total`` parameter as ``False``. "
"Moreover, :pep:`655` introduced new type qualifiers - ``typing.Required`` "
"and ``typing.NotRequired`` - that enable specifying whether a particular key "
"is required or not::"
msgstr ""

#: ../pep-0692.rst:179
msgid ""
"When using a ``TypedDict`` to type ``**kwargs`` all of the required and non-"
"required keys should correspond to required and non-required function "
"keyword parameters. Therefore, if a required key is not supported by the "
"caller, then an error must be reported by type checkers."
msgstr ""

#: ../pep-0692.rst:185
msgid "Assignment"
msgstr ""

#: ../pep-0692.rst:187
msgid ""
"Assignments of a function typed with the ``**kwargs: **Movie`` construct and "
"another callable type should pass type checking only if they are compatible. "
"This can happen for the scenarios described below."
msgstr ""

#: ../pep-0692.rst:192
msgid "Source and destination contain ``**kwargs``"
msgstr ""

#: ../pep-0692.rst:194
msgid ""
"Both destination and source functions have a ``**kwargs: **TypedDict`` "
"parameter and the destination function's ``TypedDict`` is assignable to the "
"source function's ``TypedDict`` and the rest of the parameters are "
"compatible::"
msgstr ""

#: ../pep-0692.rst:217
msgid "Source contains ``**kwargs`` and destination doesn't"
msgstr ""

#: ../pep-0692.rst:219
msgid ""
"The destination callable doesn't contain ``**kwargs``, the source callable "
"contains ``**kwargs: **TypedDict`` and the destination function's keyword "
"arguments are assignable to the corresponding keys in source function's "
"``TypedDict``. Moreover, not required keys should correspond to optional "
"function arguments, whereas required keys should correspond to required "
"function arguments. Again, the rest of the parameters have to be compatible. "
"Continuing the previous example::"
msgstr ""

#: ../pep-0692.rst:237
msgid ""
"It is worth pointing out that the destination function's parameters that are "
"to be compatible with the keys and values from the ``TypedDict`` must be "
"keyword only::"
msgstr ""

#: ../pep-0692.rst:248
msgid ""
"The reverse situation where the destination callable contains ``**kwargs: "
"**TypedDict`` and the source callable doesn't contain ``**kwargs`` should be "
"disallowed. This is because, we cannot be sure that additional keyword "
"arguments are not being passed in when an instance of a subclass had been "
"assigned to a variable with a base class type and then unpacked in the "
"destination callable invocation::"
msgstr ""

#: ../pep-0692.rst:264
msgid ""
"Similar situation can happen even without inheritance as compatibility "
"between ``TypedDict``\\s is based on structural subtyping."
msgstr ""

#: ../pep-0692.rst:268
msgid "Source contains untyped ``**kwargs``"
msgstr ""

#: ../pep-0692.rst:270
msgid ""
"The destination callable contains ``**kwargs: **TypedDict`` and the source "
"callable contains untyped ``**kwargs``::"
msgstr ""

#: ../pep-0692.rst:279
msgid "Source contains traditionally typed ``**kwargs: T``"
msgstr ""

#: ../pep-0692.rst:281
msgid ""
"The destination callable contains ``**kwargs: **TypedDict``, the source "
"callable contains traditionally typed ``**kwargs: T`` and each of the "
"destination function ``TypedDict``'s fields is assignable to a variable of "
"type ``T``::"
msgstr ""

#: ../pep-0692.rst:304
msgid ""
"On the other hand, if the destination callable contains either untyped or "
"traditionally typed ``**kwargs: T`` and the source callable is typed using "
"``**kwargs: **TypedDict`` then an error should be generated, because "
"traditionally typed ``**kwargs`` aren't checked for keyword names."
msgstr ""

#: ../pep-0692.rst:309
msgid ""
"To summarize, function parameters should behave contravariantly and function "
"return types should behave covariantly."
msgstr ""

#: ../pep-0692.rst:313
msgid "Passing kwargs inside a function to another function"
msgstr ""

#: ../pep-0692.rst:315
msgid ""
":ref:`A previous point <pep-692-assignment-dest-no-kwargs>` mentions the "
"problem of possibly passing additional keyword arguments by assigning a "
"subclass instance to a variable that has a base class type. Let's consider "
"the following example::"
msgstr ""

#: ../pep-0692.rst:351
msgid ""
"In the example above, the call to ``foo`` will not cause any issues at "
"runtime. Even though ``foo`` expects ``kwargs`` of type ``Animal`` it "
"doesn't matter if it receives additional arguments because it only reads and "
"uses what it needs completely ignoring any additional values."
msgstr ""

#: ../pep-0692.rst:356
msgid ""
"The calls to ``bar`` and ``spam`` will fail because an unexpected keyword "
"argument will be passed to the ``takes_name`` function."
msgstr ""

#: ../pep-0692.rst:359
msgid ""
"Therefore, ``kwargs`` hinted with an unpacked ``TypedDict`` can only be "
"passed to another function if the function to which unpacked kwargs are "
"being passed to has ``**kwargs`` in its signature as well, because then "
"additional keywords would not cause errors at runtime during function "
"invocation. Otherwise, the type checker should generate an error."
msgstr ""

#: ../pep-0692.rst:365
msgid ""
"In cases similar to the ``bar`` function above the problem could be worked "
"around by explicitly dereferencing desired fields and using them as "
"arguments to perform the function call::"
msgstr ""

#: ../pep-0692.rst:376
msgid "Intended Usage"
msgstr ""

#: ../pep-0692.rst:377
msgid ""
"The intended use cases for this proposal are described in the :ref:`pep-692-"
"motivation` section. In summary, more precise ``**kwargs`` typing can bring "
"benefits to already existing codebases that decided to use ``**kwargs`` "
"initially, but now are mature enough to use a stricter contract via type "
"hints. Using ``**kwargs`` can also help in reducing code duplication and the "
"amount of copy-pasting needed when there is a bunch of functions that "
"require the same set of keyword arguments. Finally, ``**kwargs`` are useful "
"for cases when a function needs to facilitate optional keyword arguments "
"that don't have obvious default values."
msgstr ""

#: ../pep-0692.rst:387
msgid ""
"However, it has to be pointed out that in some cases there are better tools "
"for the job than using ``TypedDict`` to type ``**kwargs`` as proposed in "
"this PEP. For example, when writing new code if all the keyword arguments "
"are required or have default values then writing everything explicitly is "
"better than using ``**kwargs`` and a ``TypedDict``::"
msgstr ""

#: ../pep-0692.rst:396
msgid ""
"Similarly, when type hinting third party libraries via stubs it is again "
"better to state the function signature explicitly - this is the only way to "
"type such a function if it has default arguments. Another issue that may "
"arise in this case when trying to type hint the function with a "
"``TypedDict`` is that some standard function parameters may be treated as "
"keyword only::"
msgstr ""

#: ../pep-0692.rst:413
msgid ""
"Therefore, in this case it is again preferred to type hint such function "
"explicitly as::"
msgstr ""

#: ../pep-0692.rst:418
msgid ""
"Also, for the benefit of IDEs and documentation pages, functions that are "
"part of the public API should prefer explicit keyword parameters whenever "
"possible."
msgstr ""

#: ../pep-0692.rst:422
msgid "Grammar Changes"
msgstr ""

#: ../pep-0692.rst:424
msgid ""
"This PEP requires a grammar change so that the double asterisk syntax is "
"allowed for ``**kwargs`` annotations. The proposed change is to extend the "
"``kwds`` rule in `the grammar <https://docs.python.org/3/reference/grammar."
"html>`__ as follows:"
msgstr ""

#: ../pep-0692.rst:429
msgid "Before:"
msgstr ""

#: ../pep-0692.rst:435
msgid "After:"
msgstr ""

#: ../pep-0692.rst:452
msgid ""
"A new AST node needs to be created so that type checkers can differentiate "
"the semantics of the new syntax from the existing one, which indicates that "
"all ``**kwargs`` should be of the same type. Then, whenever the new syntax "
"is used, type checkers will be able to take into account that ``**kwargs`` "
"should be unpacked. The proposition is to add a new ``DoubleStarred`` AST "
"node. Then, an AST node for the function defined as::"
msgstr ""

#: ../pep-0692.rst:461
msgid "should look as below::"
msgstr ""

#: ../pep-0692.rst:481
msgid ""
"The runtime annotations should be consistent with the AST. Continuing the "
"previous example::"
msgstr ""

#: ../pep-0692.rst:489
msgid ""
"To accomplish this, we propose a new dunder called ``__typing_unpack__``. "
"The double asterisk syntax should result in a call to the "
"``__typing_unpack__`` special method on an object it was used on. This means "
"that at runtime, ``def foo(**kwargs: **T): ...`` is equivalent to ``def "
"foo(**kwargs: type(T).__typing_unpack__(T)): ...``. ``TypedDict`` is the "
"only type in the standard library that is expected to implement "
"``__typing_unpack__``, which should return ``Unpack[self]``. The motivation "
"for reusing :pep:`646`'s ``Unpack`` is described in the :ref:`Backwards "
"Compatibility <pep-692-backwards-compatibility>` section."
msgstr ""

#: ../pep-0692.rst:499
msgid ""
"It is worth pointing out that currently using ``Unpack`` in the context of "
"typing is interchangeable with using the asterisk syntax::"
msgstr ""

#: ../pep-0692.rst:505
msgid ""
"Therefore, in order to be compatible with the new usecase, ``Unpack``'s "
"``repr`` should be changed to simply ``Unpack[T]``."
msgstr ""

#: ../pep-0692.rst:511
msgid "Backwards Compatibility"
msgstr ""

#: ../pep-0692.rst:513
msgid ""
"Using the double asterisk syntax for annotating ``**kwargs`` would be "
"available only in new versions of Python. :pep:`646` dealt with the similar "
"problem and its authors introduced a new type operator ``Unpack``. For the "
"purposes of this PEP, the proposition is to reuse ``Unpack`` for more "
"precise ``**kwargs`` typing. For example::"
msgstr ""

#: ../pep-0692.rst:521
msgid ""
"There are several reasons for reusing :pep:`646`'s ``Unpack``. Firstly, the "
"name is quite suitable and intuitive for the ``**kwargs`` typing use case as "
"the keywords arguments are \"unpacked\" from the ``TypedDict``. Secondly, "
"there would be no need to introduce any new special forms. Lastly, the use "
"of ``Unpack`` for the purposes described in this PEP does not interfere with "
"the use cases described in :pep:`646`."
msgstr ""

#: ../pep-0692.rst:529
msgid "Alternatives"
msgstr ""

#: ../pep-0692.rst:531
msgid ""
"Instead of making the grammar change, ``Unpack`` could be the only way to "
"annotate ``**kwargs`` of different types. However, introducing the double "
"asterisk syntax has two advantages. Namely, it is more concise and more "
"intuitive than using ``Unpack``."
msgstr ""

#: ../pep-0692.rst:537
msgid "How to Teach This"
msgstr ""

#: ../pep-0692.rst:539
msgid ""
"This PEP could be linked in the ``typing`` module's documentation. Moreover, "
"a new section on using ``Unpack`` as well as the new double asterisk syntax "
"could be added to the aforementioned docs. Similar sections could be also "
"added to the `mypy documentation <https://mypy.readthedocs.io/>`_ and the "
"`typing RTD documentation <https://typing.readthedocs.io/>`_."
msgstr ""

#: ../pep-0692.rst:546
msgid "Reference Implementation"
msgstr ""

#: ../pep-0692.rst:548
msgid ""
"The `mypy type checker <https://github.com/python/mypy>`_ already `supports "
"<https://github.com/python/mypy/pull/13471>`_ more precise ``**kwargs`` "
"typing using ``Unpack``."
msgstr ""

#: ../pep-0692.rst:552
msgid ""
"`Pyright type checker <https://github.com/microsoft/pyright>`_ also "
"`provides provisional support <pyrightProvisionalImplementation_>`__ for "
"`this feature <pyrightIssue3002_>`__."
msgstr ""

#: ../pep-0692.rst:556
msgid ""
"A proof-of-concept implementation of the CPython `grammar changes`_ "
"described in this PEP is `available on GitHub <cpythonGrammarChangePoc_>`__."
msgstr ""

#: ../pep-0692.rst:560
msgid "Rejected Ideas"
msgstr ""

#: ../pep-0692.rst:563
msgid "``TypedDict`` unions"
msgstr ""

#: ../pep-0692.rst:565
msgid ""
"It is possible to create unions of typed dictionaries. However, supporting "
"typing ``**kwargs`` with a union of typed dicts would greatly increase the "
"complexity of the implementation of this PEP and there seems to be no "
"compelling use case to justify the support for this. Therefore, using unions "
"of typed dictionaries to type ``**kwargs`` as described in the context of "
"this PEP can result in an error::"
msgstr ""

#: ../pep-0692.rst:583
msgid ""
"Instead, a function that expects a union of ``TypedDict``\\s can be "
"overloaded::"
msgstr ""

#: ../pep-0692.rst:603
msgid "Copyright"
msgstr "Copyright"

#: ../pep-0692.rst:605
msgid ""
"This document is placed in the public domain or under the CC0-1.0-Universal "
"license, whichever is more permissive."
msgstr ""
