# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-28 20:07+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.11.0\n"

#: ../pep-0630.rst
msgid "Author"
msgstr ""

#: ../pep-0630.rst:3
msgid "Petr Viktorin <encukou@gmail.com>"
msgstr ""

#: ../pep-0630.rst
msgid "Discussions-To"
msgstr ""

#: ../pep-0630.rst:4
msgid "capi-sig@python.org"
msgstr ""

#: ../pep-0630.rst
msgid "Status"
msgstr ""

#: ../pep-0630.rst:5
msgid "Final"
msgstr ""

#: ../pep-0630.rst
msgid "Type"
msgstr ""

#: ../pep-0630.rst:6
msgid "Informational"
msgstr ""

#: ../pep-0630.rst
msgid "Created"
msgstr ""

#: ../pep-0630.rst:8
msgid "25-Aug-2020"
msgstr ""

#: ../pep-0630.rst
msgid "Post-History"
msgstr ""

#: ../pep-0630.rst:9
msgid "16-Jul-2020"
msgstr ""

#: ../pep-0630.rst:17
msgid "Abstract"
msgstr ""

#: ../pep-0630.rst:19
msgid ""
"Traditionally, state belonging to Python extension modules was kept in C "
"``static`` variables, which have process-wide scope. This document "
"describes problems of such per-process state and efforts to make per-"
"module state—a better default—possible and easy to use."
msgstr ""

#: ../pep-0630.rst:24
msgid ""
"The document also describes how to switch to per-module state where "
"possible. This transition involves allocating space for that state, "
"potentially switching from static types to heap types, and—perhaps most "
"importantly—accessing per-module state from code."
msgstr ""

#: ../pep-0630.rst:31
msgid "About This Document"
msgstr ""

#: ../pep-0630.rst:33
msgid ""
"As an :pep:`informational PEP <1#pep-types>`, this document does not "
"introduce any changes; those should be done in their own PEPs (or issues,"
" if small enough). Rather, it covers the motivation behind an effort that"
" spans multiple releases, and instructs early adopters on how to use the "
"finished features."
msgstr ""

#: ../pep-0630.rst:39
msgid ""
"Once support is reasonably complete, this content can be moved to "
"Python's documentation as a `HOWTO "
"<https://docs.python.org/3/howto/index.html>`__. Meanwhile, in the spirit"
" of documentation-driven development, gaps identified in this PEP can "
"show where to focus the effort, and it can be updated as new features are"
" implemented."
msgstr ""

#: ../pep-0630.rst:45
msgid ""
"Whenever this PEP mentions *extension modules*, the advice also applies "
"to *built-in* modules."
msgstr ""

#: ../pep-0630.rst:49
msgid ""
"This PEP contains generic advice. When following it, always take into "
"account the specifics of your project."
msgstr ""

#: ../pep-0630.rst:52
msgid ""
"For example, while much of this advice applies to the C parts of Python's"
" standard library, the PEP does not factor in stdlib specifics (unusual "
"backward compatibility issues, access to private API, etc.)."
msgstr ""

#: ../pep-0630.rst:56
msgid "PEPs related to this effort are:"
msgstr ""

#: ../pep-0630.rst:58
msgid ""
":pep:`384` -- *Defining a Stable ABI*, which added a C API for creating "
"heap types"
msgstr ""

#: ../pep-0630.rst:60
msgid ":pep:`489` -- *Multi-phase extension module initialization*"
msgstr ""

#: ../pep-0630.rst:61
msgid ":pep:`573` -- *Module State Access from C Extension Methods*"
msgstr ""

#: ../pep-0630.rst:63
msgid ""
"This document is concerned with Python's public C API, which is not "
"offered by all implementations of Python. However, nothing in this PEP is"
" specific to CPython."
msgstr ""

#: ../pep-0630.rst:67
msgid ""
"As with any Informational PEP, this text does not necessarily represent a"
" Python community consensus or recommendation."
msgstr ""

#: ../pep-0630.rst:72
msgid "Motivation"
msgstr ""

#: ../pep-0630.rst:74
msgid ""
"An *interpreter* is the context in which Python code runs. It contains "
"configuration (e.g. the import path) and runtime state (e.g. the set of "
"imported modules)."
msgstr ""

#: ../pep-0630.rst:78
msgid ""
"Python supports running multiple interpreters in one process. There are "
"two cases to think about—users may run interpreters:"
msgstr ""

#: ../pep-0630.rst:81
msgid ""
"in sequence, with several ``Py_InitializeEx``/``Py_FinalizeEx`` cycles, "
"and"
msgstr ""

#: ../pep-0630.rst:83
msgid ""
"in parallel, managing \"sub-interpreters\" using "
"``Py_NewInterpreter``/``Py_EndInterpreter``."
msgstr ""

#: ../pep-0630.rst:86
msgid ""
"Both cases (and combinations of them) would be most useful when embedding"
" Python within a library. Libraries generally shouldn't make assumptions "
"about the application that uses them, which includes assuming a process-"
"wide \"main Python interpreter\"."
msgstr ""

#: ../pep-0630.rst:91
msgid ""
"Currently, CPython doesn't handle this use case well. Many extension "
"modules (and even some stdlib modules) use *per-process* global state, "
"because C ``static`` variables are extremely easy to use. Thus, data that"
" should be specific to an interpreter ends up being shared between "
"interpreters. Unless the extension developer is careful, it is very easy "
"to introduce edge cases that lead to crashes when a module is loaded in "
"more than one interpreter in the same process."
msgstr ""

#: ../pep-0630.rst:99
msgid ""
"Unfortunately, *per-interpreter* state is not easy to achieve—extension "
"authors tend to not keep multiple interpreters in mind when developing, "
"and it is currently cumbersome to test the behavior."
msgstr ""

#: ../pep-0630.rst:105
msgid "Rationale for Per-module State"
msgstr ""

#: ../pep-0630.rst:107
msgid ""
"Instead of focusing on per-interpreter state, Python's C API is evolving "
"to better support the more granular *per-module* state. By default, "
"C-level data will be attached to a *module object*. Each interpreter will"
" then create its own module object, keeping the data separate. For "
"testing the isolation, multiple module objects corresponding to a single "
"extension can even be loaded in a single interpreter."
msgstr ""

#: ../pep-0630.rst:114
msgid ""
"Per-module state provides an easy way to think about lifetime and "
"resource ownership: the extension module will initialize when a module "
"object is created, and clean up when it's freed. In this regard, a module"
" is just like any other ``PyObject *``; there are no \"on interpreter "
"shutdown\" hooks to think—or forget—about."
msgstr ""

#: ../pep-0630.rst:122
msgid "Goal: Easy-to-Use Module State"
msgstr ""

#: ../pep-0630.rst:124
msgid ""
"It is currently cumbersome or impossible to do everything the C API "
"offers while keeping modules isolated. Enabled by :pep:`384`, changes in "
":pep:`489` and :pep:`573` (and future planned ones) aim to first make it "
"*possible* to build modules this way, and then to make it *easy* to write"
" new modules this way and to convert old ones, so that it can become a "
"natural default."
msgstr ""

#: ../pep-0630.rst:131
msgid ""
"Even if per-module state becomes the default, there will be use cases for"
" different levels of encapsulation: per-process, per-interpreter, per-"
"thread or per-task state. The goal is to treat these as exceptional "
"cases: they should be possible, but extension authors will need to think "
"more carefully about them."
msgstr ""

#: ../pep-0630.rst:139
msgid "Non-goals: Speedups and the GIL"
msgstr ""

#: ../pep-0630.rst:141
msgid ""
"There is some effort to speed up CPython on multi-core CPUs by making the"
" GIL per-interpreter. While isolating interpreters helps that effort, "
"defaulting to per-module state will be beneficial even if no speedup is "
"achieved, as it makes supporting multiple interpreters safer by default."
msgstr ""

#: ../pep-0630.rst:148
msgid "Making Modules Safe with Multiple Interpreters"
msgstr ""

#: ../pep-0630.rst:150
msgid ""
"There are many ways to correctly support multiple interpreters in "
"extension modules. The rest of this text describes the preferred way to "
"write such a module, or to convert an existing one."
msgstr ""

#: ../pep-0630.rst:154
msgid ""
"Note that support is a work in progress; the API for some features your "
"module needs might not yet be ready."
msgstr ""

#: ../pep-0630.rst:157
msgid ""
"A full example module is available as `xxlimited "
"<https://github.com/python/cpython/blob/master/Modules/xxlimited.c>`__."
msgstr ""

#: ../pep-0630.rst:160
msgid "This section assumes that \"*you*\" are an extension module author."
msgstr ""

#: ../pep-0630.rst:164
msgid "Isolated Module Objects"
msgstr ""

#: ../pep-0630.rst:166
msgid ""
"The key point to keep in mind when developing an extension module is that"
" several module objects can be created from a single shared library. For "
"example:"
msgstr ""

#: ../pep-0630.rst:180
msgid ""
"As a rule of thumb, the two modules should be completely independent. All"
" objects and state specific to the module should be encapsulated within "
"the module object, not shared with other module objects, and cleaned up "
"when the module object is deallocated. Exceptions are possible (see "
"`Managing Global State`_), but they will need more thought and attention "
"to edge cases than code that follows this rule of thumb."
msgstr ""

#: ../pep-0630.rst:188
msgid ""
"While some modules could do with less stringent restrictions, isolated "
"modules make it easier to set clear expectations (and guidelines) that "
"work across a variety of use cases."
msgstr ""

#: ../pep-0630.rst:194
msgid "Surprising Edge Cases"
msgstr ""

#: ../pep-0630.rst:196
msgid ""
"Note that isolated modules do create some surprising edge cases. Most "
"notably, each module object will typically not share its classes and "
"exceptions with other similar modules. Continuing from the `example above"
" <Isolated Module Objects_>`__, note that ``old_binascii.Error`` and "
"``binascii.Error`` are separate objects. In the following code, the "
"exception is *not* caught:"
msgstr ""

#: ../pep-0630.rst:216
msgid ""
"This is expected. Notice that pure-Python modules behave the same way: it"
" is a part of how Python works."
msgstr ""

#: ../pep-0630.rst:219
msgid ""
"The goal is to make extension modules safe at the C level, not to make "
"hacks behave intuitively. Mutating ``sys.modules`` \"manually\" counts as"
" a hack."
msgstr ""

#: ../pep-0630.rst:225
msgid "Managing Global State"
msgstr ""

#: ../pep-0630.rst:227
msgid ""
"Sometimes, state of a Python module is not specific to that module, but "
"to the entire process (or something else \"more global\" than a module). "
"For example:"
msgstr ""

#: ../pep-0630.rst:231
msgid "The ``readline`` module manages *the* terminal."
msgstr ""

#: ../pep-0630.rst:232
msgid "A module running on a circuit board wants to control *the* on-board LED."
msgstr ""

#: ../pep-0630.rst:235
msgid ""
"In these cases, the Python module should provide *access* to the global "
"state, rather than *own* it. If possible, write the module so that "
"multiple copies of it can access the state independently (along with "
"other libraries, whether for Python or other languages)."
msgstr ""

#: ../pep-0630.rst:240
msgid "If that is not possible, consider explicit locking."
msgstr ""

#: ../pep-0630.rst:242
msgid ""
"If it is necessary to use process-global state, the simplest way to avoid"
" issues with multiple interpreters is to explicitly prevent a module from"
" being loaded more than once per process—see `Opt-Out: Limiting to One "
"Module Object per Process`_."
msgstr ""

#: ../pep-0630.rst:249
msgid "Managing Per-Module State"
msgstr ""

#: ../pep-0630.rst:251
msgid ""
"To use per-module state, use `multi-phase extension module initialization"
" <https://docs.python.org/3/c-api/module.html#multi-phase-"
"initialization>`__ introduced in :pep:`489`. This signals that your "
"module supports multiple interpreters correctly."
msgstr ""

#: ../pep-0630.rst:256
msgid ""
"Set ``PyModuleDef.m_size`` to a positive number to request that many "
"bytes of storage local to the module. Usually, this will be set to the "
"size of some module-specific ``struct``, which can store all of the "
"module's C-level state. In particular, it is where you should put "
"pointers to classes (including exceptions, but excluding static types) "
"and settings (e.g. ``csv``'s `field_size_limit "
"<https://docs.python.org/3/library/csv.html#csv.field_size_limit>`__) "
"which the C code needs to function."
msgstr ""

#: ../pep-0630.rst:266
msgid ""
"Another option is to store state in the module's ``__dict__``, but you "
"must avoid crashing when users modify ``__dict__`` from Python code. This"
" means error- and type-checking at the C level, which is easy to get "
"wrong and hard to test sufficiently."
msgstr ""

#: ../pep-0630.rst:271
msgid ""
"If the module state includes ``PyObject`` pointers, the module object "
"must hold references to those objects and implement the module-level "
"hooks ``m_traverse``, ``m_clear`` and ``m_free``. These work like "
"``tp_traverse``, ``tp_clear`` and ``tp_free`` of a class. Adding them "
"will require some work and make the code longer; this is the price for "
"modules which can be unloaded cleanly."
msgstr ""

#: ../pep-0630.rst:278
msgid ""
"An example of a module with per-module state is currently available as "
"`xxlimited "
"<https://github.com/python/cpython/blob/master/Modules/xxlimited.c>`__; "
"example module initialization shown at the bottom of the file."
msgstr ""

#: ../pep-0630.rst:284
msgid "Opt-Out: Limiting to One Module Object per Process"
msgstr ""

#: ../pep-0630.rst:286
msgid ""
"A non-negative ``PyModuleDef.m_size`` signals that a module supports "
"multiple interpreters correctly. If this is not yet the case for your "
"module, you can explicitly make your module loadable only once per "
"process. For example::"
msgstr ""

#: ../pep-0630.rst:307
msgid "Module State Access from Functions"
msgstr ""

#: ../pep-0630.rst:309
msgid ""
"Accessing the state from module-level functions is straightforward. "
"Functions get the module object as their first argument; for extracting "
"the state, you can use ``PyModule_GetState``::"
msgstr ""

#: ../pep-0630.rst:324
msgid ""
"``PyModule_GetState`` may return NULL without setting an exception if "
"there is no module state, i.e. ``PyModuleDef.m_size`` was zero. In your "
"own module, you're in control of ``m_size``, so this is easy to prevent."
msgstr ""

#: ../pep-0630.rst:331
msgid "Heap Types"
msgstr ""

#: ../pep-0630.rst:333
msgid ""
"Traditionally, types defined in C code are *static*; that is, ``static "
"PyTypeObject`` structures defined directly in code and initialized using "
"``PyType_Ready()``."
msgstr ""

#: ../pep-0630.rst:337
msgid ""
"Such types are necessarily shared across the process. Sharing them "
"between module objects requires paying attention to any state they own or"
" access. To limit the possible issues, static types are immutable at the "
"Python level: for example, you can't set ``str.myattribute = 123``."
msgstr ""

#: ../pep-0630.rst:343
msgid ""
"Sharing truly immutable objects between interpreters is fine, as long as "
"they don't provide access to mutable objects. However, in CPython, every "
"Python object has a mutable implementation detail: the reference count. "
"Changes to the refcount are guarded by the GIL. Thus, code that shares "
"any Python objects across interpreters implicitly depends on CPython's "
"current, process-wide GIL."
msgstr ""

#: ../pep-0630.rst:350
msgid ""
"Because they are immutable and process-global, static types cannot access"
" \"their\" module state. If any method of such a type requires access to "
"module state, the type must be converted to a *heap-allocated type*, or "
"*heap type* for short. These correspond more closely to classes created "
"by Python's ``class`` statement."
msgstr ""

#: ../pep-0630.rst:357
msgid "For new modules, using heap types by default is a good rule of thumb."
msgstr ""

#: ../pep-0630.rst:359
msgid ""
"Static types can be converted to heap types, but note that the heap type "
"API was not designed for \"lossless\" conversion from static types -- "
"that is, creating a type that works exactly like a given static type. "
"Unlike static types, heap type objects are mutable by default. Also, when"
" rewriting the class definition in a new API, you are likely to "
"unintentionally change a few details (e.g. pickle-ability or inherited "
"slots). Always test the details that are important to you."
msgstr ""

#: ../pep-0630.rst:369
msgid "Defining Heap Types"
msgstr ""

#: ../pep-0630.rst:371
msgid ""
"Heap types can be created by filling a ``PyType_Spec`` structure, a "
"description or \"blueprint\" of a class, and calling "
"``PyType_FromModuleAndSpec()`` to construct a new class object."
msgstr ""

#: ../pep-0630.rst:376
msgid ""
"Other functions, like ``PyType_FromSpec()``, can also create heap types, "
"but ``PyType_FromModuleAndSpec()`` associates the module with the class, "
"allowing access to the module state from methods."
msgstr ""

#: ../pep-0630.rst:380
msgid ""
"The class should generally be stored in *both* the module state (for safe"
" access from C) and the module's ``__dict__`` (for access from Python "
"code)."
msgstr ""

#: ../pep-0630.rst:386
msgid "Garbage Collection Protocol"
msgstr ""

#: ../pep-0630.rst:388
msgid ""
"Instances of heap types hold a reference to their type. This ensures that"
" the type isn't destroyed before all its instances are, but may result in"
" reference cycles that need to be broken by the garbage collector."
msgstr ""

#: ../pep-0630.rst:393
msgid ""
"To avoid memory leaks, instances of heap types must implement the garbage"
" collection protocol. That is, heap types should:"
msgstr ""

#: ../pep-0630.rst:397
msgid "Have the ``Py_TPFLAGS_HAVE_GC`` flag."
msgstr ""

#: ../pep-0630.rst:398
msgid ""
"Define a traverse function using ``Py_tp_traverse``, which visits the "
"type (e.g. using ``Py_VISIT(Py_TYPE(self));``)."
msgstr ""

#: ../pep-0630.rst:401
msgid ""
"Please refer to the `documentation "
"<https://docs.python.org/3/c-api/typeobj.html>`__ of `Py_TPFLAGS_HAVE_GC "
"<https://docs.python.org/3/c-api/typeobj.html#Py_TPFLAGS_HAVE_GC>`__ and "
"`tp_traverse "
"<https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_traverse>`"
" for additional considerations."
msgstr ""

#: ../pep-0630.rst:408
msgid ""
"If your traverse function delegates to the ``tp_traverse`` of its base "
"class (or another type), ensure that ``Py_TYPE(self)`` is visited only "
"once. Note that only heap type are expected to visit the type in "
"``tp_traverse``."
msgstr ""

#: ../pep-0630.rst:412
msgid "For example, if your traverse function includes::"
msgstr ""

#: ../pep-0630.rst:416
msgid "...and ``base`` may be a static type, then it should also include::"
msgstr ""

#: ../pep-0630.rst:424
msgid ""
"It is not necessary to handle the type's reference count in ``tp_new`` "
"and ``tp_clear``."
msgstr ""

#: ../pep-0630.rst:429
msgid "Module State Access from Classes"
msgstr ""

#: ../pep-0630.rst:431
msgid ""
"If you have a type object defined with ``PyType_FromModuleAndSpec()``, "
"you can call ``PyType_GetModule`` to get the associated module, and then "
"``PyModule_GetState`` to get the module's state."
msgstr ""

#: ../pep-0630.rst:435
msgid ""
"To save a some tedious error-handling boilerplate code, you can combine "
"these two steps with ``PyType_GetModuleState``, resulting in::"
msgstr ""

#: ../pep-0630.rst:445
msgid "Module State Access from Regular Methods"
msgstr ""

#: ../pep-0630.rst:447
msgid ""
"Accessing the module-level state from methods of a class is somewhat more"
" complicated, but is possible thanks to the changes introduced in "
":pep:`573`. To get the state, you need to first get the *defining class*,"
" and then get the module state from it."
msgstr ""

#: ../pep-0630.rst:452
msgid ""
"The largest roadblock is getting *the class a method was defined in*, or "
"that method's \"defining class\" for short. The defining class can have a"
" reference to the module it is part of."
msgstr ""

#: ../pep-0630.rst:456
msgid ""
"Do not confuse the defining class with ``Py_TYPE(self)``. If the method "
"is called on a *subclass* of your type, ``Py_TYPE(self)`` will refer to "
"that subclass, which may be defined in different module than yours."
msgstr ""

#: ../pep-0630.rst:461
msgid ""
"The following Python code can illustrate the concept. "
"``Base.get_defining_class`` returns ``Base`` even if ``type(self) == "
"Sub``:"
msgstr ""

#: ../pep-0630.rst:474
msgid ""
"For a method to get its \"defining class\", it must use the ``METH_METHOD"
" | METH_FASTCALL | METH_KEYWORDS`` `calling convention "
"<https://docs.python.org/3/c-api/structures.html#c.PyMethodDef>`__ and "
"the corresponding `PyCMethod signature "
"<https://docs.python.org/3/c-api/structures.html#c.PyCMethod>`__::"
msgstr ""

#: ../pep-0630.rst:487
msgid ""
"Once you have the defining class, call ``PyType_GetModuleState`` to get "
"the state of its associated module."
msgstr ""

#: ../pep-0630.rst:490
msgid "For example::"
msgstr ""

#: ../pep-0630.rst:518
msgid "Module State Access from Slot Methods, Getters and Setters"
msgstr ""

#: ../pep-0630.rst:522
msgid "This is new in Python 3.11."
msgstr ""

#: ../pep-0630.rst:530
msgid ""
"Slot methods -- the fast C equivalents for special methods, such as "
"`nb_add "
"<https://docs.python.org/3/c-api/typeobj.html#c.PyNumberMethods.nb_add>`__"
" for ``__add__`` or `tp_new "
"<https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_new>`__ "
"for initialization -- have a very simple API that doesn't allow passing "
"in the defining class, unlike with ``PyCMethod``. The same goes for "
"getters and setters defined with `PyGetSetDef "
"<https://docs.python.org/3/c-api/structures.html#c.PyGetSetDef>`__."
msgstr ""

#: ../pep-0630.rst:539
msgid ""
"To access the module state in these cases, use the `PyType_GetModuleByDef"
" "
"<https://docs.python.org/3/c-api/typeobj.html#c.PyType_GetModuleByDef>`__"
" function, and pass in the module definition. Once you have the module, "
"call `PyModule_GetState "
"<https://docs.python.org/3/c-api/module.html#c.PyModule_GetState>`__ to "
"get the state::"
msgstr ""

#: ../pep-0630.rst:552
msgid ""
"``PyType_GetModuleByDef`` works by searching the `MRO "
"<https://docs.python.org/3/glossary.html#term-method-resolution-order>`__"
" (i.e. all superclasses) for the first superclass that has a "
"corresponding module."
msgstr ""

#: ../pep-0630.rst:559
msgid ""
"In very exotic cases (inheritance chains spanning multiple modules "
"created from the same definition), ``PyType_GetModuleByDef`` might not "
"return the module of the true defining class. However, it will always "
"return a module with the same definition, ensuring a compatible C memory "
"layout."
msgstr ""

#: ../pep-0630.rst:567
msgid "Lifetime of the Module State"
msgstr ""

#: ../pep-0630.rst:569
msgid ""
"When a module object is garbage-collected, its module state is freed. For"
" each pointer to (a part of) the module state, you must hold a reference "
"to the module object."
msgstr ""

#: ../pep-0630.rst:573
msgid ""
"Usually this is not an issue, because types created with "
"``PyType_FromModuleAndSpec``, and their instances, hold a reference to "
"the module. However, you must be careful in reference counting when you "
"reference module state from other places, such as callbacks for external "
"libraries."
msgstr ""

#: ../pep-0630.rst:582
msgid "Open Issues"
msgstr ""

#: ../pep-0630.rst:584
msgid "Several issues around per-module state and heap types are still open."
msgstr ""

#: ../pep-0630.rst:586
msgid ""
"Discussions about improving the situation are best held on the `capi-sig "
"mailing list <https://mail.python.org/mailman3/lists/capi-"
"sig.python.org/>`__."
msgstr ""

#: ../pep-0630.rst:591
msgid "Type Checking"
msgstr ""

#: ../pep-0630.rst:593
msgid ""
"Currently (as of Python 3.10), heap types have no good API to write "
"``Py*_Check`` functions (like ``PyUnicode_Check`` exists for ``str``, a "
"static type), and so it is not easy to ensure that instances have a "
"particular C layout."
msgstr ""

#: ../pep-0630.rst:600
msgid "Metaclasses"
msgstr ""

#: ../pep-0630.rst:602
msgid ""
"Currently (as of Python 3.10), there is no good API to specify the "
"*metaclass* of a heap type; that is, the ``ob_type`` field of the type "
"object."
msgstr ""

#: ../pep-0630.rst:608
msgid "Per-Class Scope"
msgstr ""

#: ../pep-0630.rst:610
msgid ""
"It is also not possible to attach state to *types*. While "
"``PyHeapTypeObject`` is a variable-size object (``PyVarObject``), its "
"variable-size storage is currently consumed by slots. Fixing this is "
"complicated by the fact that several classes in an inheritance hierarchy "
"may need to reserve some state."
msgstr ""

#: ../pep-0630.rst:618
msgid "Lossless Conversion to Heap Types"
msgstr ""

#: ../pep-0630.rst:620
msgid ""
"The heap type API was not designed for \"lossless\" conversion from "
"static types; that is, creating a type that works exactly like a given "
"static type. The best way to address it would probably be to write a "
"guide that covers known \"gotchas\"."
msgstr ""

#: ../pep-0630.rst:627
msgid "Copyright"
msgstr ""

#: ../pep-0630.rst:629
msgid ""
"This document is placed in the public domain or under the "
"CC0-1.0-Universal license, whichever is more permissive."
msgstr ""

