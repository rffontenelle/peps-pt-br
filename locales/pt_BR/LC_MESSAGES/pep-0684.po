# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-28 20:07+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.11.0\n"

#: ../pep-0684.rst
msgid "Author"
msgstr ""

#: ../pep-0684.rst:3
msgid "Eric Snow <ericsnowcurrently@gmail.com>"
msgstr ""

#: ../pep-0684.rst
msgid "Discussions-To"
msgstr ""

#: ../pep-0684.rst:4
msgid "https://discuss.python.org/t/pep-684-a-per-interpreter-gil/19583"
msgstr ""

#: ../pep-0684.rst
msgid "Status"
msgstr ""

#: ../pep-0684.rst:5
msgid "Draft"
msgstr ""

#: ../pep-0684.rst
msgid "Type"
msgstr ""

#: ../pep-0684.rst:6
msgid "Standards Track"
msgstr ""

#: ../pep-0684.rst
msgid "Requires"
msgstr ""

#: ../pep-0684.rst:8
msgid "683"
msgstr ""

#: ../pep-0684.rst
msgid "Created"
msgstr ""

#: ../pep-0684.rst:9
msgid "08-Mar-2022"
msgstr ""

#: ../pep-0684.rst
msgid "Python-Version"
msgstr ""

#: ../pep-0684.rst:10
msgid "3.12"
msgstr ""

#: ../pep-0684.rst
msgid "Post-History"
msgstr ""

#: ../pep-0684.rst:11
msgid ""
"`08-Mar-2022 <https://mail.python.org/archives/list/python-dev@python.org/"
"thread/CF7B7FMACFYDAHU6NPBEVEY6TOSGICXU/>`__, `29-Sep-2022 <https://discuss."
"python.org/t/pep-684-a-per-interpreter-gil/19583>`__,"
msgstr ""

#: ../pep-0684.rst
msgid "Resolution"
msgstr ""

#: ../pep-0684.rst:17
msgid "Abstract"
msgstr ""

#: ../pep-0684.rst:19
msgid ""
"Since Python 1.5 (1997), CPython users can run multiple interpreters in the "
"same process.  However, interpreters in the same process have always shared "
"a significant amount of global state.  This is a source of bugs, with a "
"growing impact as more and more people use the feature.  Furthermore, "
"sufficient isolation would facilitate true multi-core parallelism, where "
"interpreters no longer share the GIL.  The changes outlined in this proposal "
"will result in that level of interpreter isolation."
msgstr ""

#: ../pep-0684.rst:30
msgid "High-Level Summary"
msgstr ""

#: ../pep-0684.rst:32
msgid "At a high level, this proposal changes CPython in the following ways:"
msgstr ""

#: ../pep-0684.rst:34
msgid "stops sharing the GIL between interpreters, given sufficient isolation"
msgstr ""

#: ../pep-0684.rst:35
msgid "adds several new interpreter config options for isolation settings"
msgstr ""

#: ../pep-0684.rst:36
msgid "keeps incompatible extensions from causing problems"
msgstr ""

#: ../pep-0684.rst:39
msgid "The GIL"
msgstr ""

#: ../pep-0684.rst:41
msgid ""
"The GIL protects concurrent access to most of CPython's runtime state. So "
"all that GIL-protected global state must move to each interpreter before the "
"GIL can."
msgstr ""

#: ../pep-0684.rst:45
msgid ""
"(In a handful of cases, other mechanisms can be used to ensure thread-safe "
"sharing instead, such as locks or \"immortal\" objects.)"
msgstr ""

#: ../pep-0684.rst:49
msgid "CPython Runtime State"
msgstr ""

#: ../pep-0684.rst:51
msgid ""
"Properly isolating interpreters requires that most of CPython's runtime "
"state be stored in the ``PyInterpreterState`` struct.  Currently, only a "
"portion of it is; the rest is found either in C global variables or in "
"``_PyRuntimeState``.  Most of that will have to be moved."
msgstr ""

#: ../pep-0684.rst:56
msgid ""
"This directly coincides with an ongoing effort (of many years) to greatly "
"reduce internal use of global variables and consolidate the runtime state "
"into ``_PyRuntimeState`` and ``PyInterpreterState``. (See `Consolidating "
"Runtime Global State`_ below.)  That project has `significant merit on its "
"own <Benefits to Consolidation_>`_ and has faced little controversy.  So, "
"while a per-interpreter GIL relies on the completion of that effort, that "
"project should not be considered a part of this proposal--only a dependency."
msgstr ""

#: ../pep-0684.rst:66
msgid "Other Isolation Considerations"
msgstr ""

#: ../pep-0684.rst:68
msgid ""
"CPython's interpreters must be strictly isolated from each other, with few "
"exceptions.  To a large extent they already are.  Each interpreter has its "
"own copy of all modules, classes, functions, and variables. The CPython C-"
"API docs `explain further <caveats_>`_."
msgstr ""

#: ../pep-0684.rst:75
msgid ""
"However, aside from what has already been mentioned (e.g. the GIL), there "
"are a couple of ways in which interpreters still share some state."
msgstr ""

#: ../pep-0684.rst:78
msgid ""
"First of all, some process-global resources (e.g. memory, file descriptors, "
"environment variables) are shared.  There are no plans to change this."
msgstr ""

#: ../pep-0684.rst:82
msgid ""
"Second, some isolation is faulty due to bugs or implementations that did not "
"take multiple interpreters into account.  This includes CPython's runtime "
"and the stdlib, as well as extension modules that rely on global variables.  "
"Bugs should be opened in these cases, as some already have been."
msgstr ""

#: ../pep-0684.rst:89
msgid "Depending on Immortal Objects"
msgstr ""

#: ../pep-0684.rst:91
msgid ""
":pep:`683` introduces immortal objects as a CPython-internal feature. With "
"immortal objects, we can share any otherwise immutable global objects "
"between all interpreters.  Consequently, this PEP does not need to address "
"how to deal with the various objects `exposed in the public C-API <capi "
"objects_>`_. It also simplifies the question of what to do about the builtin "
"static types.  (See `Global Objects`_ below.)"
msgstr ""

#: ../pep-0684.rst:99
msgid ""
"Both issues have alternate solutions, but everything is simpler with "
"immortal objects.  If PEP 683 is not accepted then this one will be updated "
"with the alternatives.  This lets us reduce noise in this proposal."
msgstr ""

#: ../pep-0684.rst:106
msgid "Motivation"
msgstr ""

#: ../pep-0684.rst:108
msgid ""
"The fundamental problem we're solving here is a lack of true multi-core "
"parallelism (for Python code) in the CPython runtime.  The GIL is the "
"cause.  While it usually isn't a problem in practice, at the very least it "
"makes Python's multi-core story murky, which makes the GIL a consistent "
"distraction."
msgstr ""

#: ../pep-0684.rst:114
msgid ""
"Isolated interpreters are also an effective mechanism to support certain "
"concurrency models.  :pep:`554` discusses this in more detail."
msgstr ""

#: ../pep-0684.rst:118
msgid "Indirect Benefits"
msgstr ""

#: ../pep-0684.rst:120
msgid ""
"Most of the effort needed for a per-interpreter GIL has benefits that make "
"those tasks worth doing anyway:"
msgstr ""

#: ../pep-0684.rst:123
msgid "makes multiple-interpreter behavior more reliable"
msgstr ""

#: ../pep-0684.rst:124
msgid ""
"has led to fixes for long-standing runtime bugs that otherwise hadn't been "
"prioritized"
msgstr ""

#: ../pep-0684.rst:126
msgid ""
"has been exposing (and inspiring fixes for) previously unknown runtime bugs"
msgstr ""

#: ../pep-0684.rst:127
msgid "has driven cleaner runtime initialization (:pep:`432`, :pep:`587`)"
msgstr ""

#: ../pep-0684.rst:128
msgid "has driven cleaner and more complete runtime finalization"
msgstr ""

#: ../pep-0684.rst:129
msgid "led to structural layering of the C-API (e.g. ``Include/internal``)"
msgstr ""

#: ../pep-0684.rst:130
msgid "also see `Benefits to Consolidation`_ below"
msgstr ""

#: ../pep-0684.rst:134
msgid "Furthermore, much of that work benefits other CPython-related projects:"
msgstr ""

#: ../pep-0684.rst:136
msgid "performance improvements (\"`faster-cpython`_\")"
msgstr ""

#: ../pep-0684.rst:137
msgid "pre-fork application deployment (e.g. `Instagram server`_)"
msgstr ""

#: ../pep-0684.rst:138
msgid "extension module isolation (see :pep:`630`, etc.)"
msgstr ""

#: ../pep-0684.rst:139
msgid "embedding CPython"
msgstr ""

#: ../pep-0684.rst:146
msgid "Existing Use of Multiple Interpreters"
msgstr ""

#: ../pep-0684.rst:148
msgid ""
"The C-API for multiple interpreters has been used for many years. However, "
"until relatively recently the feature wasn't widely known, nor extensively "
"used (with the exception of mod_wsgi)."
msgstr ""

#: ../pep-0684.rst:152
msgid ""
"In the last few years use of multiple interpreters has been increasing. Here "
"are some of the public projects using the feature currently:"
msgstr ""

#: ../pep-0684.rst:155
msgid "`mod_wsgi <https://github.com/GrahamDumpleton/mod_wsgi>`_"
msgstr ""

#: ../pep-0684.rst:156
msgid "`OpenStack Ceph <https://github.com/ceph/ceph/pull/14971>`_"
msgstr ""

#: ../pep-0684.rst:157
msgid "`JEP <https://github.com/ninia/jep>`_"
msgstr ""

#: ../pep-0684.rst:158
msgid "`Kodi <https://github.com/xbmc/xbmc>`_"
msgstr ""

#: ../pep-0684.rst:160
msgid ""
"Note that, with :pep:`554`, multiple interpreter usage would likely grow "
"significantly (via Python code rather than the C-API)."
msgstr ""

#: ../pep-0684.rst:164
msgid "PEP 554 (Multiple Interpreters in the Stdlib)"
msgstr ""

#: ../pep-0684.rst:166
msgid ""
":pep:`554` is strictly about providing a minimal stdlib module to give users "
"access to multiple interpreters from Python code. In fact, it specifically "
"avoids proposing any changes related to the GIL.  Consider, however, that "
"users of that module would benefit from a per-interpreter GIL, which makes "
"PEP 554 more appealing."
msgstr ""

#: ../pep-0684.rst:174
msgid "Rationale"
msgstr ""

#: ../pep-0684.rst:176
msgid ""
"During initial investigations in 2014, a variety of possible solutions for "
"multi-core Python were explored, but each had its drawbacks without simple "
"solutions:"
msgstr ""

#: ../pep-0684.rst:180
msgid "the existing practice of releasing the GIL in extension modules"
msgstr ""

#: ../pep-0684.rst:182
msgid "doesn't help with Python code"
msgstr ""

#: ../pep-0684.rst:184
msgid "other Python implementations (e.g. Jython, IronPython)"
msgstr ""

#: ../pep-0684.rst:186
msgid "CPython dominates the community"
msgstr ""

#: ../pep-0684.rst:188
msgid "remove the GIL (e.g. gilectomy, \"no-gil\")"
msgstr ""

#: ../pep-0684.rst:190
msgid "too much technical risk (at the time)"
msgstr ""

#: ../pep-0684.rst:192
msgid "Trent Nelson's \"PyParallel\" project"
msgstr ""

#: ../pep-0684.rst:194
msgid "incomplete; Windows-only at the time"
msgstr ""

#: ../pep-0684.rst:196
msgid "``multiprocessing``"
msgstr ""

#: ../pep-0684.rst:198
msgid ""
"too much work to make it effective enough; high penalties in some situations "
"(at large scale, Windows)"
msgstr ""

#: ../pep-0684.rst:201
msgid "other parallelism tools (e.g. dask, ray, MPI)"
msgstr ""

#: ../pep-0684.rst:203
msgid "not a fit for the runtime/stdlib"
msgstr ""

#: ../pep-0684.rst:205
msgid "give up on multi-core (e.g. async, do nothing)"
msgstr ""

#: ../pep-0684.rst:207
msgid "this can only end in tears"
msgstr ""

#: ../pep-0684.rst:209
msgid ""
"Even in 2014, it was fairly clear that a solution using isolated "
"interpreters did not have a high level of technical risk and that most of "
"the work was worth doing anyway. (The downside was the volume of work to be "
"done.)"
msgstr ""

#: ../pep-0684.rst:216
msgid "Specification"
msgstr ""

#: ../pep-0684.rst:218
msgid ""
"As `summarized above <High-Level Summary_>`__, this proposal involves the "
"following changes, in the order they must happen:"
msgstr ""

#: ../pep-0684.rst:221
msgid ""
"`consolidate global runtime state <Consolidating Runtime Global State_>`_ "
"(including objects) into ``_PyRuntimeState``"
msgstr ""

#: ../pep-0684.rst:223
msgid "move nearly all of the state down into ``PyInterpreterState``"
msgstr ""

#: ../pep-0684.rst:224
msgid "finally, move the GIL down into ``PyInterpreterState``"
msgstr ""

#: ../pep-0684.rst:225
msgid "everything else"
msgstr ""

#: ../pep-0684.rst:227
msgid "update the C-API"
msgstr ""

#: ../pep-0684.rst:228
msgid "implement extension module restrictions"
msgstr ""

#: ../pep-0684.rst:229
msgid ""
"work with popular extension maintainers to help with multi-interpreter "
"support"
msgstr ""

#: ../pep-0684.rst:233
msgid "Per-Interpreter State"
msgstr ""

#: ../pep-0684.rst:235
msgid "The following runtime state will be moved to ``PyInterpreterState``:"
msgstr ""

#: ../pep-0684.rst:237
msgid "all global objects that are not safely shareable (fully immutable)"
msgstr ""

#: ../pep-0684.rst:238
msgid "the GIL"
msgstr ""

#: ../pep-0684.rst:239
msgid "most mutable data that's currently protected by the GIL"
msgstr ""

#: ../pep-0684.rst:240
msgid ""
"mutable data that's currently protected by some other per-interpreter lock"
msgstr ""

#: ../pep-0684.rst:241
msgid ""
"mutable data that may be used independently in different interpreters (also "
"applies to extension modules, including those with multi-phase init)"
msgstr ""

#: ../pep-0684.rst:243
msgid "all other mutable data not otherwise excluded below"
msgstr ""

#: ../pep-0684.rst:245
msgid ""
"Furthermore, a portion of the full global state has already been moved to "
"the interpreter, including GC, warnings, and atexit hooks."
msgstr ""

#: ../pep-0684.rst:248
msgid "The following runtime state will not be moved:"
msgstr ""

#: ../pep-0684.rst:250
msgid "global objects that are safely shareable, if any"
msgstr ""

#: ../pep-0684.rst:251
msgid "immutable data, often ``const``"
msgstr ""

#: ../pep-0684.rst:252
msgid "effectively immutable data (treated as immutable), for example:"
msgstr ""

#: ../pep-0684.rst:254
msgid "some state is initialized early and never modified again"
msgstr ""

#: ../pep-0684.rst:255
msgid ""
"hashes for strings (``PyUnicodeObject``) are idempotently calculated when "
"first needed and then cached"
msgstr ""

#: ../pep-0684.rst:258
msgid ""
"all data that is guaranteed to be modified exclusively in the main thread, "
"including:"
msgstr ""

#: ../pep-0684.rst:261
msgid "state used only in CPython's ``main()``"
msgstr ""

#: ../pep-0684.rst:262
msgid "the REPL's state"
msgstr ""

#: ../pep-0684.rst:263
msgid ""
"data modified only during runtime init (effectively immutable afterward)"
msgstr ""

#: ../pep-0684.rst:265
msgid "mutable data that's protected by some global lock (other than the GIL)"
msgstr ""

#: ../pep-0684.rst:266
msgid "global state in atomic variables"
msgstr ""

#: ../pep-0684.rst:267
msgid "mutable global state that can be changed (sensibly) to atomic variables"
msgstr ""

#: ../pep-0684.rst:270
msgid "Memory Allocators"
msgstr ""

#: ../pep-0684.rst:272
msgid ""
"This is one of the most sensitive parts of the work to isolate interpreters. "
"The simplest solution is to move the global state of the internal \"small "
"block\" allocator to ``PyInterpreterState``, as we are doing with nearly all "
"other runtime state.  The following elaborates on the details and rationale."
msgstr ""

#: ../pep-0684.rst:278
msgid ""
"CPython provides a memory management C-API, with `three allocator domains`_: "
"\"raw\", \"mem\", and \"object\".  Each provides the equivalent of "
"``malloc()``, ``calloc()``, ``realloc()``, and ``free()``.  A custom "
"allocator for each domain can be set during runtime initialization and the "
"current allocator can be wrapped with a hook using the same API (for "
"example, the stdlib tracemalloc module).  The allocators are currently "
"runtime-global, shared by all interpreters."
msgstr ""

#: ../pep-0684.rst:288
msgid ""
"The \"raw\" allocator is expected to be thread-safe and defaults to glibc's "
"allocator (``malloc()``, etc.).  However, the \"mem\" and \"object\" "
"allocators are not expected to be thread-safe and currently may rely on the "
"GIL for thread-safety.  This is partly because the default allocator for "
"both, AKA \"pyobject\", `is not thread-safe`_.  This is due to how all state "
"for that allocator is stored in C global variables. (See ``Objects/obmalloc."
"c``.)"
msgstr ""

#: ../pep-0684.rst:298
msgid ""
"Thus we come back to the question of isolating runtime state.  In order for "
"interpreters to stop sharing the GIL, allocator thread-safety must be "
"addressed.  If interpreters continue sharing the allocators then we need "
"some other way to get thread-safety.  Otherwise interpreters must stop "
"sharing the allocators.  In both cases there are a number of possible "
"solutions, each with potential downsides."
msgstr ""

#: ../pep-0684.rst:305
msgid ""
"To keep sharing the allocators, the simplest solution is to use a granular "
"runtime-global lock around the calls to the \"mem\" and \"object\" "
"allocators in ``PyMem_Malloc()``, ``PyObject_Malloc()``, etc.  This would "
"impact performance, but there are some ways to mitigate that (e.g. only "
"start locking once the first subinterpreter is created)."
msgstr ""

#: ../pep-0684.rst:311
msgid ""
"Another way to keep sharing the allocators is to require that the \"mem\" "
"and \"object\" allocators be thread-safe.  This would mean we'd have to make "
"the pyobject allocator implementation thread-safe.  That could even involve "
"re-implementing it using an extensible allocator like mimalloc.  The "
"potential downside is in the cost to re-implement the allocator and the risk "
"of defects inherent to such an endeavor."
msgstr ""

#: ../pep-0684.rst:318
msgid ""
"Regardless, a switch to requiring thread-safe allocators would impact anyone "
"that embeds CPython and currently sets a thread-unsafe allocator. We'd need "
"to consider who might be affected and how we reduce any negative impact (e."
"g. add a basic C-API to help make an allocator thread-safe)."
msgstr ""

#: ../pep-0684.rst:324
msgid ""
"If we did stop sharing the allocators between interpreters, we'd have to do "
"so only for the \"mem\" and \"object\" allocators.  We might also need to "
"keep a full set of global allocators for certain runtime-level usage. There "
"would be some performance penalty due to looking up the current interpreter "
"and then pointer indirection to get the allocators. Embedders would also "
"likely have to provide a new allocator context for each interpreter.  On the "
"plus side, allocator hooks (e.g. tracemalloc) would not be affected."
msgstr ""

#: ../pep-0684.rst:333
msgid "Ultimately, we will go with the simplest option:"
msgstr ""

#: ../pep-0684.rst:335
msgid "keep the allocators in the global runtime state"
msgstr ""

#: ../pep-0684.rst:336
msgid "require that they be thread-safe"
msgstr ""

#: ../pep-0684.rst:337
msgid ""
"move the state of the default object allocator (AKA \"small block\" "
"allocator) to ``PyInterpreterState``"
msgstr ""

#: ../pep-0684.rst:340
msgid ""
"We experimented with `a rough implementation`_ and found it was fairly "
"straightforward, and the performance penalty was essentially zero."
msgstr ""

#: ../pep-0684.rst:348
msgid "C-API"
msgstr ""

#: ../pep-0684.rst:350
msgid ""
"Internally, the interpreter state will now track how the import system "
"should handle extension modules which do not support use with multiple "
"interpreters.  See `Restricting Extension Modules`_ below.  We'll refer to "
"that setting here as \"PyInterpreterState.strict_extension_compat\"."
msgstr ""

#: ../pep-0684.rst:355
msgid "The following API will be made public, if they haven't been already:"
msgstr ""

#: ../pep-0684.rst:357
msgid "``PyInterpreterConfig`` (struct)"
msgstr ""

#: ../pep-0684.rst:358
msgid "``PyInterpreterConfig_INIT`` (macro)"
msgstr ""

#: ../pep-0684.rst:359
msgid "``PyInterpreterConfig_LEGACY_INIT`` (macro)"
msgstr ""

#: ../pep-0684.rst:360
msgid "``PyThreadState * Py_NewInterpreterFromConfig(PyInterpreterConfig *)``"
msgstr ""

#: ../pep-0684.rst:362
msgid "We will add two new fields to ``PyInterpreterConfig``:"
msgstr ""

#: ../pep-0684.rst:364
msgid "``int own_gil``"
msgstr ""

#: ../pep-0684.rst:365
msgid "``int strict_extensions_compat``"
msgstr ""

#: ../pep-0684.rst:367
msgid ""
"We may add other fields over time, as needed (e.g. \"own_initial_thread\")."
msgstr ""

#: ../pep-0684.rst:369
msgid ""
"Regarding the initializer macros, ``PyInterpreterConfig_INIT`` would be used "
"to get an isolated interpreter that also avoids subinterpreter-unfriendly "
"features.  It would be the default for interpreters created through :pep:"
"`554`.  The unrestricted (status quo) will continue to be available through "
"``PyInterpreterConfig_LEGACY_INIT``, which is already used for the main "
"interpreter and ``Py_NewInterpreter()``. This will not change."
msgstr ""

#: ../pep-0684.rst:377
msgid "A note about the \"main\" interpreter:"
msgstr ""

#: ../pep-0684.rst:379
msgid ""
"Below, we mention the \"main\" interpreter several times.  This refers to "
"the interpreter created during runtime initialization, for which the initial "
"``PyThreadState`` corresponds to the process's main thread. It is has a "
"number of unique responsibilities (e.g. handling signals), as well as a "
"special role during runtime initialization/finalization. It is also usually "
"(for now) the only interpreter. (Also see https://docs.python.org/3/c-api/"
"init.html#sub-interpreter-support.)"
msgstr ""

#: ../pep-0684.rst:388
msgid "PyInterpreterConfig.own_gil"
msgstr ""

#: ../pep-0684.rst:390
msgid ""
"If ``true`` (``1``) then the new interpreter will have its own \"global\" "
"interpreter lock.  This means the new interpreter can run without getting "
"interrupted by other interpreters.  This effectively unblocks full use of "
"multiple cores.  That is the fundamental goal of this PEP."
msgstr ""

#: ../pep-0684.rst:395
msgid ""
"If ``false`` (``0``) then the new interpreter will use the main "
"interpreter's lock.  This is the legacy (pre-3.12) behavior in CPython, "
"where all interpreters share a single GIL.  Sharing the GIL like this may be "
"desirable when using extension modules that still depend on the GIL for "
"thread safety."
msgstr ""

#: ../pep-0684.rst:401
msgid ""
"In ``PyInterpreterConfig_INIT``, this will be ``true``. In "
"``PyInterpreterConfig_LEGACY_INIT``, this will be ``false``."
msgstr ""

#: ../pep-0684.rst:405
msgid "PyInterpreterConfig.strict_extensions_compat"
msgstr ""

#: ../pep-0684.rst:407
msgid ""
"``PyInterpreterConfig.strict_extension_compat`` is basically the initial "
"value used for \"PyInterpreterState.strict_extension_compat\"."
msgstr ""

#: ../pep-0684.rst:411
msgid "Restricting Extension Modules"
msgstr ""

#: ../pep-0684.rst:413
msgid ""
"Extension modules have many of the same problems as the runtime when state "
"is stored in global variables.  :pep:`630` covers all the details of what "
"extensions must do to support isolation, and thus safely run in multiple "
"interpreters at once.  This includes dealing with their globals."
msgstr ""

#: ../pep-0684.rst:418
msgid ""
"If an extension implements multi-phase init (see :pep:`489`) it is "
"considered compatible with multiple interpreters.  All other extensions are "
"considered incompatible.  (See `Extension Module Thread Safety`_ for more "
"details about how a per-interpreter GIL may affect that classification.)"
msgstr ""

#: ../pep-0684.rst:424
msgid ""
"If an incompatible extension is imported and the current "
"\"PyInterpreterState.strict_extension_compat\" value is ``true`` then the "
"import system will raise ``ImportError``.  (For ``false`` it simply doesn't "
"check.) This will be done through ``importlib._bootstrap_external."
"ExtensionFileLoader`` (really, through ``_imp.create_dynamic()``, "
"``_PyImport_LoadDynamicModuleWithSpec()``, and "
"``PyModule_FromDefAndSpec2()``)."
msgstr ""

#: ../pep-0684.rst:432
msgid ""
"Such imports will never fail in the main interpreter (or in interpreters "
"created through ``Py_NewInterpreter()``) since \"PyInterpreterState."
"strict_extension_compat\" initializes to ``false`` in both cases.  Thus the "
"legacy (pre-3.12) behavior is preserved."
msgstr ""

#: ../pep-0684.rst:437
msgid ""
"We will work with popular extensions to help them support use in multiple "
"interpreters.  This may involve adding to CPython's public C-API, which we "
"will address on a case-by-case basis."
msgstr ""

#: ../pep-0684.rst:442
msgid "Extension Module Compatibility"
msgstr ""

#: ../pep-0684.rst:444
msgid ""
"As noted in `Extension Modules`_, many extensions work fine in multiple "
"interpreters (and under a per-interpreter GIL) without needing any changes.  "
"The import system will still fail if such a module doesn't explicitly "
"indicate support.  At first, not many extension modules will, so this is a "
"potential source of frustration."
msgstr ""

#: ../pep-0684.rst:450
msgid ""
"We will address this by adding a context manager to temporarily disable the "
"check on multiple interpreter support: ``importlib.util."
"allow_all_extensions()``.  More or less, it will modify the current "
"\"PyInterpreterState.strict_extension_compat\" value (e.g. through a private "
"``sys`` function)."
msgstr ""

#: ../pep-0684.rst:457
msgid "Extension Module Thread Safety"
msgstr ""

#: ../pep-0684.rst:459
msgid ""
"If a module supports use with multiple interpreters, that mostly implies it "
"will work even if those interpreters do not share the GIL.  The one caveat "
"is where a module links against a library with internal global state that "
"isn't thread-safe.  (Even something as innocuous as a static local variable "
"as a temporary buffer can be a problem.)  With a shared GIL, that state is "
"protected.  Without one, such modules must wrap any use of that state (e.g. "
"through calls) with a lock."
msgstr ""

#: ../pep-0684.rst:467
msgid ""
"Currently, it isn't clear whether or not supports-multiple-interpreters is "
"sufficiently equivalent to supports-per-interpreter-gil, such that we can "
"avoid any special accommodations.  This is still a point of meaningful "
"discussion and investigation.  The practical distinction between the two (in "
"the Python community, e.g. PyPI) is not yet understood well enough to settle "
"the matter.  Likewise, it isn't clear what we might be able to do to help "
"extension maintainers mitigate the problem (assuming it is one)."
msgstr ""

#: ../pep-0684.rst:476
msgid ""
"In the meantime, we must proceed as though the difference would be large "
"enough to cause problems for enough extension modules out there. The "
"solution we would apply is:"
msgstr ""

#: ../pep-0684.rst:480
msgid ""
"add a ``PyModuleDef`` slot that indicates an extension can be imported under "
"a per-interpreter GIL (i.e. opt in)"
msgstr ""

#: ../pep-0684.rst:482
msgid ""
"add that slot as part of the definition of a \"compatible\" extension, as "
"discussed earlier"
msgstr ""

#: ../pep-0684.rst:485
msgid ""
"The downside is that not a single extension module will be able to take "
"advantage of the per-interpreter GIL without extra effort by the module "
"maintainer, regardless of how minor that effort.  This compounds the problem "
"described in `Extension Module Compatibility`_ and the same workaround "
"applies.  Ideally, we would determine that there isn't enough difference to "
"matter."
msgstr ""

#: ../pep-0684.rst:492
msgid ""
"If we do end up requiring an opt-in for imports under a per-interpreter GIL, "
"and later determine it isn't necessary, then we can switch the default at "
"that point, make the old opt-in slot a noop, and add a new ``PyModuleDef`` "
"slot for explicitly opting *out*.  In fact, it makes sense to add that opt-"
"out slot from the beginning."
msgstr ""

#: ../pep-0684.rst:500
msgid "Documentation"
msgstr ""

#: ../pep-0684.rst:502
msgid ""
"C-API: the \"Sub-interpreter support\" section of ``Doc/c-api/init.rst`` "
"will detail the updated API"
msgstr ""

#: ../pep-0684.rst:504
msgid ""
"C-API: that section will explain about the consequences of a per-interpreter "
"GIL"
msgstr ""

#: ../pep-0684.rst:506
msgid ""
"importlib: the ``ExtensionFileLoader`` entry will note import may fail in "
"subinterpreters"
msgstr ""

#: ../pep-0684.rst:508
msgid ""
"importlib: there will be a new entry about ``importlib.util."
"allow_all_extensions()``"
msgstr ""

#: ../pep-0684.rst:513
msgid "Impact"
msgstr ""

#: ../pep-0684.rst:516
msgid "Backwards Compatibility"
msgstr ""

#: ../pep-0684.rst:518
msgid ""
"No behavior or APIs are intended to change due to this proposal, with two "
"exceptions:"
msgstr ""

#: ../pep-0684.rst:521
msgid ""
"some extensions will fail to import in some subinterpreters (see `the next "
"section <Extension Modules_>`_)"
msgstr ""

#: ../pep-0684.rst:523
msgid ""
"\"mem\" and \"object\" allocators that are currently not thread-safe may now "
"be susceptible to data races when used in combination with multiple "
"interpreters"
msgstr ""

#: ../pep-0684.rst:527
msgid ""
"The existing C-API for managing interpreters will preserve its current "
"behavior, with new behavior exposed through new API.  No other API or "
"runtime behavior is meant to change, including compatibility with the stable "
"ABI."
msgstr ""

#: ../pep-0684.rst:532
msgid "See `Objects Exposed in the C-API`_ below for related discussion."
msgstr ""

#: ../pep-0684.rst:535
msgid "Extension Modules"
msgstr ""

#: ../pep-0684.rst:537
msgid ""
"Currently the most common usage of Python, by far, is with the main "
"interpreter running by itself.  This proposal has zero impact on extension "
"modules in that scenario.  Likewise, for better or worse, there is no change "
"in behavior under multiple interpreters created using the existing "
"``Py_NewInterpreter()``."
msgstr ""

#: ../pep-0684.rst:543
msgid ""
"Keep in mind that some extensions already break when used in multiple "
"interpreters, due to keeping module state in global variables (or due to the "
"`internal state of linked libraries`_).  They may crash or, worse, "
"experience inconsistent behavior.  That was part of the motivation for :pep:"
"`630` and friends, so this is not a new situation nor a consequence of this "
"proposal."
msgstr ""

#: ../pep-0684.rst:552
msgid ""
"In contrast, when the `proposed API <proposed capi_>`_ is used to create "
"multiple interpreters, with the appropriate settings, the behavior will "
"change for incompatible extensions.  In that case, importing such an "
"extension will fail (outside the main interpreter), as explained in "
"`Restricting Extension Modules`_.  For extensions that already break in "
"multiple interpreters, this will be an improvement."
msgstr ""

#: ../pep-0684.rst:559
msgid ""
"Additionally, some extension modules link against libraries with thread-"
"unsafe internal global state. (See `Extension Module Thread Safety`_.) Such "
"modules will have to start wrapping any direct or indirect use of that state "
"in a lock.  This is the key difference from other modules that also "
"implement multi-phase init and thus indicate support for multiple "
"interpreters (i.e. isolation)."
msgstr ""

#: ../pep-0684.rst:567
msgid ""
"Now we get to the break in compatibility mentioned above.  Some extensions "
"are safe under multiple interpreters (and a per-interpreter GIL), even "
"though they haven't indicated that.  Unfortunately, there is no reliable way "
"for the import system to infer that such an extension is safe, so importing "
"them will still fail.  This case is addressed in `Extension Module "
"Compatibility`_ above."
msgstr ""

#: ../pep-0684.rst:575
msgid "Extension Module Maintainers"
msgstr ""

#: ../pep-0684.rst:577
msgid ""
"One related consideration is that a per-interpreter GIL will likely drive "
"increased use of multiple interpreters, particularly if :pep:`554` is "
"accepted.  Some maintainers of large extension modules have expressed "
"concern about the increased burden they anticipate due to increased use of "
"multiple interpreters."
msgstr ""

#: ../pep-0684.rst:583
msgid ""
"Specifically, enabling support for multiple interpreters will require "
"substantial work for some extension modules (albeit likely not many). To add "
"that support, the maintainer(s) of such a module (often volunteers) would "
"have to set aside their normal priorities and interests to focus on "
"compatibility (see :pep:`630`)."
msgstr ""

#: ../pep-0684.rst:589
msgid ""
"Of course, extension maintainers are free to not add support for use in "
"multiple interpreters.  However, users will increasingly demand such "
"support, especially if the feature grows in popularity."
msgstr ""

#: ../pep-0684.rst:593
msgid ""
"Either way, the situation can be stressful for maintainers of such "
"extensions, particularly when they are doing the work in their spare time.  "
"The concerns they have expressed are understandable, and we address the "
"partial solution in the `Restricting Extension Modules`_ and `Extension "
"Module Compatibility`_ sections."
msgstr ""

#: ../pep-0684.rst:600
msgid "Alternate Python Implementations"
msgstr ""

#: ../pep-0684.rst:602
msgid ""
"Other Python implementation are not required to provide support for multiple "
"interpreters in the same process (though some do already)."
msgstr ""

#: ../pep-0684.rst:606
msgid "Security Implications"
msgstr ""

#: ../pep-0684.rst:608
msgid "There is no known impact to security with this proposal."
msgstr ""

#: ../pep-0684.rst:611
msgid "Maintainability"
msgstr ""

#: ../pep-0684.rst:613
msgid ""
"On the one hand, this proposal has already motivated a number of "
"improvements that make CPython *more* maintainable.  That is expected to "
"continue.  On the other hand, the underlying work has already exposed "
"various pre-existing defects in the runtime that have had to be fixed.  That "
"is also expected to continue as multiple interpreters receive more use.  "
"Otherwise, there shouldn't be a significant impact on maintainability, so "
"the net effect should be positive."
msgstr ""

#: ../pep-0684.rst:622
msgid "Performance"
msgstr ""

#: ../pep-0684.rst:624
msgid ""
"The work to consolidate globals has already provided a number of "
"improvements to CPython's performance, both speeding it up and using less "
"memory, and this should continue. The performance benefits of a per-"
"interpreter GIL specifically have not been explored.  At the very least, it "
"is not expected to make CPython slower (as long as interpreters are "
"sufficiently isolated).  And, obviously, it enable a variety of multi-core "
"parallelism in Python code."
msgstr ""

#: ../pep-0684.rst:634
msgid "How to Teach This"
msgstr ""

#: ../pep-0684.rst:636
msgid ""
"Unlike :pep:`554`, this is an advanced feature meant for a narrow set of "
"users of the C-API.  There is no expectation that the specifics of the API "
"nor its direct application will be taught."
msgstr ""

#: ../pep-0684.rst:640
msgid "That said, if it were taught then it would boil down to the following:"
msgstr ""

#: ../pep-0684.rst:642
msgid ""
"In addition to Py_NewInterpreter(), you can use "
"Py_NewInterpreterFromConfig() to create an interpreter. The config you pass "
"it indicates how you want that interpreter to behave."
msgstr ""

#: ../pep-0684.rst:647
msgid ""
"Furthermore, the maintainers of any extension modules that create isolated "
"interpreters will likely need to explain the consequences of a per-"
"interpreter GIL to their users.  The first thing to explain is what :pep:"
"`554` teaches about the concurrency model that isolated interpreters "
"enables.  That leads into the point that Python software written using that "
"concurrency model can then take advantage of multi-core parallelism, which "
"is currently prevented by the GIL."
msgstr ""

#: ../pep-0684.rst:661
msgid "Reference Implementation"
msgstr ""

#: ../pep-0684.rst:663 ../pep-0684.rst:696
msgid "<TBD>"
msgstr ""

#: ../pep-0684.rst:667
msgid "Open Issues"
msgstr ""

#: ../pep-0684.rst:669
msgid ""
"Are we okay to require \"mem\" and \"object\" allcoators to be thread-safe?"
msgstr ""

#: ../pep-0684.rst:670
msgid ""
"How would a per-interpreter tracemalloc module relate to global allocators?"
msgstr ""

#: ../pep-0684.rst:671
msgid ""
"Would the faulthandler module be limited to the main interpreter (like the "
"signal module) or would we leak that global state between interpreters "
"(protected by a granular lock)?"
msgstr ""

#: ../pep-0684.rst:674
msgid ""
"Split out an informational PEP with all the relevant info, based on the "
"\"Consolidating Runtime Global State\" section?"
msgstr ""

#: ../pep-0684.rst:676
msgid ""
"How likely is it that a module works under multiple interpreters (isolation) "
"but doesn't work under a per-interpreter GIL? (See `Extension Module Thread "
"Safety`_.)"
msgstr ""

#: ../pep-0684.rst:679
msgid ""
"If it is likely enough, what can we do to help extension maintainers "
"mitigate the problem and enjoy use under a per-intepreter GIL?"
msgstr ""

#: ../pep-0684.rst:681
msgid ""
"What would be a better (scarier-sounding) name for ``allow_all_extensions``?"
msgstr ""

#: ../pep-0684.rst:686
msgid "Deferred Functionality"
msgstr ""

#: ../pep-0684.rst:688
msgid ""
"``PyInterpreterConfig`` option to always run the interpreter in a new thread"
msgstr ""

#: ../pep-0684.rst:689
msgid ""
"``PyInterpreterConfig`` option to assign a \"main\" thread to the "
"interpreter and only run in that thread"
msgstr ""

#: ../pep-0684.rst:694
msgid "Rejected Ideas"
msgstr ""

#: ../pep-0684.rst:700
msgid "Extra Context"
msgstr ""

#: ../pep-0684.rst:703
msgid "Sharing Global Objects"
msgstr ""

#: ../pep-0684.rst:705
msgid ""
"We are sharing some global objects between interpreters. This is an "
"implementation detail and relates more to `globals consolidation "
"<Consolidating Runtime Global State>`_ than to this proposal, but it is a "
"significant enough detail to explain here."
msgstr ""

#: ../pep-0684.rst:711
msgid ""
"The alternative is to share no objects between interpreters, ever. To "
"accomplish that, we'd have to sort out the fate of all our static types, as "
"well as deal with compatibility issues for the many objects `exposed in the "
"public C-API <capi objects_>`_."
msgstr ""

#: ../pep-0684.rst:716
msgid ""
"That approach introduces a meaningful amount of extra complexity and higher "
"risk, though prototyping has demonstrated valid solutions. Also, it would "
"likely result in a performance penalty."
msgstr ""

#: ../pep-0684.rst:720
msgid ""
"`Immortal objects <Depending on Immortal Objects_>`_ allow us to share the "
"otherwise immutable global objects.  That way we avoid the extra costs."
msgstr ""

#: ../pep-0684.rst:727
msgid "Objects Exposed in the C-API"
msgstr ""

#: ../pep-0684.rst:729
msgid ""
"The C-API (including the limited API) exposes all the builtin types, "
"including the builtin exceptions, as well as the builtin singletons. The "
"exceptions are exposed as ``PyObject *`` but the rest are exposed as the "
"static values rather than pointers.  This was one of the few non-trivial "
"problems we had to solve for per-interpreter GIL."
msgstr ""

#: ../pep-0684.rst:735
msgid "With immortal objects this is a non-issue."
msgstr ""

#: ../pep-0684.rst:739
msgid "Consolidating Runtime Global State"
msgstr ""

#: ../pep-0684.rst:741
msgid ""
"As noted in `CPython Runtime State`_ above, there is an active effort "
"(separate from this PEP) to consolidate CPython's global state into the "
"``_PyRuntimeState`` struct.  Nearly all the work involves moving that state "
"from global variables.  The project is particularly relevant to this "
"proposal, so below is some extra detail."
msgstr ""

#: ../pep-0684.rst:748
msgid "Benefits to Consolidation"
msgstr ""

#: ../pep-0684.rst:750
msgid "Consolidating the globals has a variety of benefits:"
msgstr ""

#: ../pep-0684.rst:752
msgid "greatly reduces the number of C globals (best practice for C code)"
msgstr ""

#: ../pep-0684.rst:753
msgid "the move draws attention to runtime state that is unstable or broken"
msgstr ""

#: ../pep-0684.rst:754
msgid "encourages more consistency in how runtime state is used"
msgstr ""

#: ../pep-0684.rst:755
msgid "makes it easier to discover/identify CPython's runtime state"
msgstr ""

#: ../pep-0684.rst:756
msgid ""
"makes it easier to statically allocate runtime state in a consistent way"
msgstr ""

#: ../pep-0684.rst:757
msgid "better memory locality for runtime state"
msgstr ""

#: ../pep-0684.rst:759
msgid ""
"Furthermore all the benefits listed in `Indirect Benefits`_ above also apply "
"here, and the same projects listed there benefit."
msgstr ""

#: ../pep-0684.rst:763
msgid "Scale of Work"
msgstr ""

#: ../pep-0684.rst:765
msgid ""
"The number of global variables to be moved is large enough to matter, but "
"most are Python objects that can be dealt with in large groups (like "
"``Py_IDENTIFIER``).  In nearly all cases, moving these globals to the "
"interpreter is highly mechanical.  That doesn't require cleverness but "
"instead requires someone to put in the time."
msgstr ""

#: ../pep-0684.rst:772
msgid "State To Be Moved"
msgstr ""

#: ../pep-0684.rst:774
msgid "The remaining global variables can be categorized as follows:"
msgstr ""

#: ../pep-0684.rst:776
msgid "global objects"
msgstr ""

#: ../pep-0684.rst:778
msgid "static types (incl. exception types)"
msgstr ""

#: ../pep-0684.rst:779
msgid "non-static types (incl. heap types, structseq types)"
msgstr ""

#: ../pep-0684.rst:780
msgid "singletons (static)"
msgstr ""

#: ../pep-0684.rst:781
msgid "singletons (initialized once)"
msgstr ""

#: ../pep-0684.rst:782
msgid "cached objects"
msgstr ""

#: ../pep-0684.rst:784
msgid "non-objects"
msgstr ""

#: ../pep-0684.rst:786
msgid "will not (or unlikely to) change after init"
msgstr ""

#: ../pep-0684.rst:787
msgid "only used in the main thread"
msgstr ""

#: ../pep-0684.rst:788
msgid "initialized lazily"
msgstr ""

#: ../pep-0684.rst:789
msgid "pre-allocated buffers"
msgstr ""

#: ../pep-0684.rst:790
msgid "state"
msgstr ""

#: ../pep-0684.rst:792
msgid ""
"Those globals are spread between the core runtime, the builtin modules, and "
"the stdlib extension modules."
msgstr ""

#: ../pep-0684.rst:795
msgid "For a breakdown of the remaining globals, run:"
msgstr ""

#: ../pep-0684.rst:802
msgid "Already Completed Work"
msgstr ""

#: ../pep-0684.rst:804
msgid ""
"As mentioned, this work has been going on for many years.  Here are some of "
"the things that have already been done:"
msgstr ""

#: ../pep-0684.rst:807
msgid "cleanup of runtime initialization (see :pep:`432` / :pep:`587`)"
msgstr ""

#: ../pep-0684.rst:808
msgid ""
"extension module isolation machinery (see :pep:`384` / :pep:`3121` / :pep:"
"`489`)"
msgstr ""

#: ../pep-0684.rst:809
msgid "isolation for many builtin modules"
msgstr ""

#: ../pep-0684.rst:810
msgid "isolation for many stdlib extension modules"
msgstr ""

#: ../pep-0684.rst:811
msgid "addition of ``_PyRuntimeState``"
msgstr ""

#: ../pep-0684.rst:812
msgid "no more ``_Py_IDENTIFIER()``"
msgstr ""

#: ../pep-0684.rst:813
msgid "statically allocated:"
msgstr ""

#: ../pep-0684.rst:815
msgid "empty string"
msgstr ""

#: ../pep-0684.rst:816
msgid "string literals"
msgstr ""

#: ../pep-0684.rst:817
msgid "identifiers"
msgstr ""

#: ../pep-0684.rst:818
msgid "latin-1 strings"
msgstr ""

#: ../pep-0684.rst:819
msgid "length-1 bytes"
msgstr ""

#: ../pep-0684.rst:820
msgid "empty tuple"
msgstr ""

#: ../pep-0684.rst:823
msgid "Tooling"
msgstr ""

#: ../pep-0684.rst:825
msgid ""
"As already indicated, there are several tools to help identify the globals "
"and reason about them."
msgstr ""

#: ../pep-0684.rst:828
msgid ""
"``Tools/c-analyzer/cpython/globals-to-fix.tsv`` - the list of remaining "
"globals"
msgstr ""

#: ../pep-0684.rst:829
msgid "``Tools/c-analyzer/c-analyzer.py``"
msgstr ""

#: ../pep-0684.rst:831
msgid "``analyze`` - identify all the globals"
msgstr ""

#: ../pep-0684.rst:832
msgid ""
"``check`` - fail if there are any unsupported globals that aren't ignored"
msgstr ""

#: ../pep-0684.rst:834
msgid "``Tools/c-analyzer/table-file.py`` - summarize the known globals"
msgstr ""

#: ../pep-0684.rst:836
msgid ""
"Also, the check for unsupported globals is incorporated into CI so that no "
"new globals are accidentally added."
msgstr ""

#: ../pep-0684.rst:840
msgid "Global Objects"
msgstr ""

#: ../pep-0684.rst:842
msgid ""
"Global objects that are safe to be shared (without a GIL) between "
"interpreters can stay on ``_PyRuntimeState``.  Not only must the object be "
"effectively immutable (e.g. singletons, strings), but not even the refcount "
"can change for it to be safe.  Immortality (:pep:`683`) provides that.  (The "
"alternative is that no objects are shared, which adds significant complexity "
"to the solution, particularly for the objects `exposed in the public C-API "
"<capi objects_>`_.)"
msgstr ""

#: ../pep-0684.rst:850
msgid ""
"Builtin static types are a special case of global objects that will be "
"shared.  They are effectively immutable except for one part: "
"``__subclasses__`` (AKA ``tp_subclasses``).  We expect that nothing else on "
"a builtin type will change, even the content of ``__dict__`` (AKA "
"``tp_dict``)."
msgstr ""

#: ../pep-0684.rst:856
msgid ""
"``__subclasses__`` for the builtin types will be dealt with by making it a "
"getter that does a lookup on the current ``PyInterpreterState`` for that "
"type."
msgstr ""

#: ../pep-0684.rst:862
msgid "References"
msgstr ""

#: ../pep-0684.rst:864
msgid "Related:"
msgstr ""

#: ../pep-0684.rst:866
msgid ":pep:`384` \"Defining a Stable ABI\""
msgstr ""

#: ../pep-0684.rst:867
msgid ":pep:`432` \"Restructuring the CPython startup sequence\""
msgstr ""

#: ../pep-0684.rst:868
msgid ":pep:`489` \"Multi-phase extension module initialization\""
msgstr ""

#: ../pep-0684.rst:869
msgid ":pep:`554` \"Multiple Interpreters in the Stdlib\""
msgstr ""

#: ../pep-0684.rst:870
msgid ":pep:`573` \"Module State Access from C Extension Methods\""
msgstr ""

#: ../pep-0684.rst:871
msgid ":pep:`587` \"Python Initialization Configuration\""
msgstr ""

#: ../pep-0684.rst:872
msgid ":pep:`630` \"Isolating Extension Modules\""
msgstr ""

#: ../pep-0684.rst:873
msgid ":pep:`683` \"Immortal Objects, Using a Fixed Refcount\""
msgstr ""

#: ../pep-0684.rst:874
msgid ":pep:`3121` \"Extension Module Initialization and Finalization\""
msgstr ""

#: ../pep-0684.rst:878
msgid "Copyright"
msgstr ""

#: ../pep-0684.rst:880
msgid ""
"This document is placed in the public domain or under the CC0-1.0-Universal "
"license, whichever is more permissive."
msgstr ""
