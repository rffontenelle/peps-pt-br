# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-28 20:07+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.11.0\n"

#: ../pep-0593.rst
msgid "Author"
msgstr "Autor"

#: ../pep-0593.rst:3
msgid "Till Varoquaux <till@fb.com>, Konstantin Kashin <kkashin@fb.com>"
msgstr ""

#: ../pep-0593.rst
msgid "Sponsor"
msgstr ""

#: ../pep-0593.rst:4
msgid "Ivan Levkivskyi <levkivskyi@gmail.com>"
msgstr ""

#: ../pep-0593.rst
msgid "Discussions-To"
msgstr ""

#: ../pep-0593.rst:5
msgid "typing-sig@python.org"
msgstr ""

#: ../pep-0593.rst
msgid "Status"
msgstr "Status"

#: ../pep-0593.rst:6
msgid "Accepted"
msgstr ""

#: ../pep-0593.rst
msgid "Type"
msgstr "Tipo"

#: ../pep-0593.rst:7
msgid "Standards Track"
msgstr ""

#: ../pep-0593.rst
msgid "Topic"
msgstr ""

#: ../pep-0593.rst:8
msgid "Typing"
msgstr ""

#: ../pep-0593.rst
msgid "Created"
msgstr "Criada em"

#: ../pep-0593.rst:10
msgid "26-Apr-2019"
msgstr ""

#: ../pep-0593.rst
msgid "Python-Version"
msgstr ""

#: ../pep-0593.rst:11
msgid "3.9"
msgstr ""

#: ../pep-0593.rst
msgid "Post-History"
msgstr "Pós-história"

#: ../pep-0593.rst:12
msgid "20-May-2019"
msgstr ""

#: ../pep-0593.rst:15
msgid "Abstract"
msgstr ""

#: ../pep-0593.rst:17
msgid ""
"This PEP introduces a mechanism to extend the type annotations from PEP 484 "
"with arbitrary metadata."
msgstr ""

#: ../pep-0593.rst:21
msgid "Motivation"
msgstr ""

#: ../pep-0593.rst:23
msgid ""
":pep:`484` provides a standard semantic for the annotations introduced in :"
"pep:`3107`. :pep:`484` is prescriptive but it is the de facto standard for "
"most of the consumers of annotations; in many statically checked code bases, "
"where type annotations are widely used, they have effectively crowded out "
"any other form of annotation. Some of the use cases for annotations "
"described in :pep:`3107` (database mapping, foreign languages bridge) are "
"not currently realistic given the prevalence of type annotations. "
"Furthermore, the standardisation of type annotations rules out advanced "
"features only supported by specific type checkers."
msgstr ""

#: ../pep-0593.rst:35
msgid "Rationale"
msgstr ""

#: ../pep-0593.rst:37
msgid ""
"This PEP adds an ``Annotated`` type to the typing module to decorate "
"existing types with context-specific metadata. Specifically, a type ``T`` "
"can be annotated with metadata ``x`` via the typehint ``Annotated[T, x]``. "
"This metadata can be used for either static analysis or at runtime. If a "
"library (or tool) encounters a typehint ``Annotated[T, x]`` and has no "
"special logic for metadata ``x``, it should ignore it and simply treat the "
"type as ``T``. Unlike the ``no_type_check`` functionality that currently "
"exists in the ``typing`` module which completely disables typechecking "
"annotations on a function or a class, the ``Annotated`` type allows for both "
"static typechecking of ``T`` (e.g., via `mypy <mypy_>`_ or `Pyre <pyre_>`_, "
"which can safely ignore ``x``) together with runtime access to ``x`` within "
"a specific application. The introduction of this type would address a "
"diverse set of use cases of interest to the broader Python community."
msgstr ""

#: ../pep-0593.rst:53
msgid ""
"This was originally brought up as `issue 600 <issue-600_>`_ in the typing "
"github and then discussed in `Python ideas <python-ideas_>`_."
msgstr ""

#: ../pep-0593.rst:57
msgid "Motivating examples"
msgstr ""

#: ../pep-0593.rst:60
msgid "Combining runtime and static uses of annotations"
msgstr ""

#: ../pep-0593.rst:62
msgid ""
"There's an emerging trend of libraries leveraging the typing annotations at "
"runtime (e.g.: dataclasses); having the ability to extend the typing "
"annotations with external data would be a great boon for those libraries."
msgstr ""

#: ../pep-0593.rst:66
msgid ""
"Here's an example of how a hypothetical module could leverage annotations to "
"read c structs::"
msgstr ""

#: ../pep-0593.rst:83
msgid "Lowering barriers to developing new typing constructs"
msgstr ""

#: ../pep-0593.rst:85
msgid ""
"Typically when adding a new type, a developer need to upstream that type to "
"the typing module and change mypy, `PyCharm <pycharm_>`_, Pyre, `pytype "
"<pytype_>`_, etc... This is particularly important when working on open-"
"source code that makes use of these types, seeing as the code would not be "
"immediately transportable to other developers' tools without additional "
"logic. As a result, there is a high cost to developing and trying out new "
"types in a codebase. Ideally, authors should be able to introduce new types "
"in a manner that allows for graceful degradation (e.g.: when clients do not "
"have a custom `mypy plugin <mypy-plugin_>`_), which would lower the barrier "
"to development and ensure some degree of backward compatibility."
msgstr ""

#: ../pep-0593.rst:97
msgid ""
"For example, suppose that an author wanted to add support for `tagged unions "
"<tagged-union_>`_ to Python. One way to accomplish would be to `annotate "
"<typed-dict_>`_ ``TypedDict`` in Python such that only one field is allowed "
"to be set::"
msgstr ""

#: ../pep-0593.rst:107
msgid ""
"This is a somewhat cumbersome syntax but it allows us to iterate on this "
"proof-of-concept and have people with type checkers (or other tools) that "
"don't yet support this feature work in a codebase with tagged unions. The "
"author could easily test this proposal and iron out the kinks before trying "
"to upstream tagged union to ``typing``, mypy, etc. Moreover, tools that do "
"not have support for parsing the ``TaggedUnion`` annotation would still be "
"able to treat ``Currency`` as a ``TypedDict``, which is still a close "
"approximation (slightly less strict)."
msgstr ""

#: ../pep-0593.rst:116
msgid "Specification"
msgstr ""

#: ../pep-0593.rst:119
msgid "Syntax"
msgstr ""

#: ../pep-0593.rst:121
msgid ""
"``Annotated`` is parameterized with a type and an arbitrary list of Python "
"values that represent the annotations. Here are the specific details of the "
"syntax:"
msgstr ""

#: ../pep-0593.rst:125
msgid "The first argument to ``Annotated`` must be a valid type"
msgstr ""

#: ../pep-0593.rst:127
msgid ""
"Multiple type annotations are supported (``Annotated`` supports variadic "
"arguments)::"
msgstr ""

#: ../pep-0593.rst:132
msgid ""
"``Annotated`` must be called with at least two arguments "
"( ``Annotated[int]`` is not valid)"
msgstr ""

#: ../pep-0593.rst:135
msgid ""
"The order of the annotations is preserved and matters for equality checks::"
msgstr ""

#: ../pep-0593.rst:142
msgid ""
"Nested ``Annotated`` types are flattened, with metadata ordered starting "
"with the innermost annotation::"
msgstr ""

#: ../pep-0593.rst:149
msgid "Duplicated annotations are not removed::"
msgstr ""

#: ../pep-0593.rst:155
msgid "``Annotated`` can be used with nested and generic aliases::"
msgstr ""

#: ../pep-0593.rst:164
msgid "Consuming annotations"
msgstr ""

#: ../pep-0593.rst:166
msgid ""
"Ultimately, the responsibility of how to interpret the annotations (if at "
"all) is the responsibility of the tool or library encountering the "
"``Annotated`` type. A tool or library encountering an ``Annotated`` type can "
"scan through the annotations to determine if they are of interest (e.g., "
"using ``isinstance()``)."
msgstr ""

#: ../pep-0593.rst:172
msgid ""
"**Unknown annotations:** When a tool or a library does not support "
"annotations or encounters an unknown annotation it should just ignore it and "
"treat annotated type as the underlying type. For example, when encountering "
"an annotation that is not an instance of ``struct2.ctype`` to the "
"annotations for name (e.g., ``Annotated[str, 'foo', struct2."
"ctype(\"<10s\")]``), the unpack method should ignore it."
msgstr ""

#: ../pep-0593.rst:179
msgid ""
"**Namespacing annotations:** Namespaces are not needed for annotations since "
"the class used by the annotations acts as a namespace."
msgstr ""

#: ../pep-0593.rst:182
msgid ""
"**Multiple annotations:** It's up to the tool consuming the annotations to "
"decide whether the client is allowed to have several annotations on one type "
"and how to merge those annotations."
msgstr ""

#: ../pep-0593.rst:186
msgid ""
"Since the ``Annotated`` type allows you to put several annotations of the "
"same (or different) type(s) on any node, the tools or libraries consuming "
"those annotations are in charge of dealing with potential duplicates. For "
"example, if you are doing value range analysis you might allow this::"
msgstr ""

#: ../pep-0593.rst:195
msgid "Flattening nested annotations, this translates to::"
msgstr ""

#: ../pep-0593.rst:200
msgid "Interaction with ``get_type_hints()``"
msgstr ""

#: ../pep-0593.rst:202
msgid ""
"``typing.get_type_hints()`` will take a new argument ``include_extras`` that "
"defaults to ``False`` to preserve backward compatibility. When "
"``include_extras`` is ``False``, the extra annotations will be stripped out "
"of the returned value. Otherwise, the annotations will be returned "
"unchanged::"
msgstr ""

#: ../pep-0593.rst:219
msgid "Aliases & Concerns over verbosity"
msgstr ""

#: ../pep-0593.rst:221
msgid ""
"Writing ``typing.Annotated`` everywhere can be quite verbose; fortunately, "
"the ability to alias annotations means that in practice we don't expect "
"clients to have to write lots of boilerplate code::"
msgstr ""

#: ../pep-0593.rst:233
msgid "Rejected ideas"
msgstr ""

#: ../pep-0593.rst:235
msgid ""
"Some of the proposed ideas were rejected from this PEP because they would "
"cause ``Annotated`` to not integrate cleanly with the other typing "
"annotations:"
msgstr ""

#: ../pep-0593.rst:238
msgid ""
"``Annotated`` cannot infer the decorated type. You could imagine that "
"``Annotated[..., Immutable]`` could be used to mark a value as immutable "
"while still inferring its type. Typing does not support using the inferred "
"type `anywhere else <issue-276_>`_; it's best to not add this as a special "
"case."
msgstr ""

#: ../pep-0593.rst:244
msgid ""
"Using ``(Type, Ann1, Ann2, ...)`` instead of ``Annotated[Type, Ann1, "
"Ann2, ...]``. This would cause confusion when annotations appear in nested "
"positions (``Callable[[A, B], C]`` is too similar to ``Callable[[(A, B)], "
"C]``) and would make it impossible for constructors to be passthrough "
"(``T(5) == C(5)`` when ``C = Annotation[T, Ann]``)."
msgstr ""

#: ../pep-0593.rst:250
msgid "This feature was left out to keep the design simple:"
msgstr ""

#: ../pep-0593.rst:252
msgid ""
"``Annotated`` cannot be called with a single argument. Annotated could "
"support returning the underlying value when called with a single argument (e."
"g.: ``Annotated[int] == int``). This complicates the specifications and adds "
"little benefit."
msgstr ""

#: ../pep-0593.rst:289
msgid "Copyright"
msgstr "Copyright"

#: ../pep-0593.rst:291
msgid "This document has been placed in the public domain."
msgstr "Este documento foi colocado em domínio público."
