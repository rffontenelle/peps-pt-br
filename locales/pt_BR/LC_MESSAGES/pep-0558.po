# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-28 20:07+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.11.0\n"

#: ../pep-0558.rst
msgid "Author"
msgstr "Autor"

#: ../pep-0558.rst:3
msgid "Nick Coghlan <ncoghlan@gmail.com>"
msgstr ""

#: ../pep-0558.rst
msgid "BDFL-Delegate"
msgstr ""

#: ../pep-0558.rst:4
msgid "Nathaniel J. Smith"
msgstr ""

#: ../pep-0558.rst
msgid "Discussions-To"
msgstr ""

#: ../pep-0558.rst:5
msgid "python-dev@python.org"
msgstr ""

#: ../pep-0558.rst
msgid "Status"
msgstr "Status"

#: ../pep-0558.rst:6
msgid "Draft"
msgstr ""

#: ../pep-0558.rst
msgid "Type"
msgstr "Tipo"

#: ../pep-0558.rst:7
msgid "Standards Track"
msgstr ""

#: ../pep-0558.rst
msgid "Created"
msgstr "Criada em"

#: ../pep-0558.rst:9
msgid "08-Sep-2017"
msgstr ""

#: ../pep-0558.rst
msgid "Python-Version"
msgstr ""

#: ../pep-0558.rst:10
msgid "3.12"
msgstr ""

#: ../pep-0558.rst
msgid "Post-History"
msgstr "Pós-história"

#: ../pep-0558.rst:11
msgid ""
"08-Sep-2017, 22-May-2019, 30-May-2019, 30-Dec-2019, 18-Jul-2021, 26-Aug-2021"
msgstr ""

#: ../pep-0558.rst:16
msgid "Abstract"
msgstr ""

#: ../pep-0558.rst:18
msgid ""
"The semantics of the ``locals()`` builtin have historically been "
"underspecified and hence implementation dependent."
msgstr ""

#: ../pep-0558.rst:21
msgid ""
"This PEP proposes formally standardising on the behaviour of the CPython "
"3.10 reference implementation for most execution scopes, with some "
"adjustments to the behaviour at function scope to make it more predictable "
"and independent of the presence or absence of tracing functions."
msgstr ""

#: ../pep-0558.rst:26
msgid ""
"In addition, it proposes that the following functions be added to the stable "
"Python C API/ABI:"
msgstr ""

#: ../pep-0558.rst:42
msgid ""
"It also proposes the addition of several supporting functions and type "
"definitions to the CPython C API."
msgstr ""

#: ../pep-0558.rst:47
msgid "Motivation"
msgstr ""

#: ../pep-0558.rst:49
msgid ""
"While the precise semantics of the ``locals()`` builtin are nominally "
"undefined, in practice, many Python programs depend on it behaving exactly "
"as it behaves in CPython (at least when no tracing functions are installed)."
msgstr ""

#: ../pep-0558.rst:53
msgid ""
"Other implementations such as PyPy are currently replicating that behaviour, "
"up to and including replication of local variable mutation bugs that can "
"arise when a trace hook is installed [1]_."
msgstr ""

#: ../pep-0558.rst:57
msgid ""
"While this PEP considers CPython's current behaviour when no trace hooks are "
"installed to be largely acceptable, it considers the current behaviour when "
"trace hooks are installed to be problematic, as it causes bugs like [1]_ "
"*without* even reliably enabling the desired functionality of allowing "
"debuggers like ``pdb`` to mutate local variables [3]_."
msgstr ""

#: ../pep-0558.rst:63
msgid ""
"Review of the initial PEP and the draft implementation then identified an "
"opportunity for simplification of both the documentation and implementation "
"of the function level ``locals()`` behaviour by updating it to return an "
"independent snapshot of the function locals and closure variables on each "
"call, rather than continuing to return the semi-dynamic intermittently "
"updated shared copy that it has historically returned in CPython."
msgstr ""

#: ../pep-0558.rst:72
msgid "Proposal"
msgstr ""

#: ../pep-0558.rst:74
msgid ""
"The expected semantics of the ``locals()`` builtin change based on the "
"current execution scope. For this purpose, the defined scopes of execution "
"are:"
msgstr ""

#: ../pep-0558.rst:77
msgid ""
"module scope: top-level module code, as well as any other code executed "
"using ``exec()`` or ``eval()`` with a single namespace"
msgstr ""

#: ../pep-0558.rst:79
msgid ""
"class scope: code in the body of a ``class`` statement, as well as any other "
"code executed using ``exec()`` or ``eval()`` with separate local and global "
"namespaces"
msgstr ""

#: ../pep-0558.rst:82
msgid ""
"function scope: code in the body of a ``def`` or ``async def`` statement, or "
"any other construct that creates an optimized code block in CPython (e.g. "
"comprehensions, lambda functions)"
msgstr ""

#: ../pep-0558.rst:86
msgid ""
"This PEP proposes elevating most of the current behaviour of the CPython "
"reference implementation to become part of the language specification, "
"*except* that each call to ``locals()`` at function scope will create a new "
"dictionary object, rather than caching a common dict instance in the frame "
"object that each invocation will update and return."
msgstr ""

#: ../pep-0558.rst:92
msgid ""
"This PEP also proposes to largely eliminate the concept of a separate "
"\"tracing\" mode from the CPython reference implementation. In releases up "
"to and including Python 3.10, the CPython interpreter behaves differently "
"when a trace hook has been registered in one or more threads via an "
"implementation dependent mechanism like ``sys.settrace`` ([4]_) in CPython's "
"``sys`` module or ``PyEval_SetTrace`` ([5]_) in CPython's C API. If this PEP "
"is accepted, then the only remaining behavioural difference when a trace "
"hook is installed is that some optimisations in the interpreter eval loop "
"are disabled when the tracing logic needs to run after each opcode."
msgstr ""

#: ../pep-0558.rst:102
msgid ""
"This PEP proposes changes to CPython's behaviour at function scope that make "
"the ``locals()`` builtin semantics when a trace hook is registered identical "
"to those used when no trace hook is registered, while also making the "
"related frame API semantics clearer and easier for interactive debuggers to "
"rely on."
msgstr ""

#: ../pep-0558.rst:107
msgid ""
"The proposed elimination of tracing mode affects the semantics of frame "
"object references obtained through other means, such as via a traceback, or "
"via the ``sys._getframe()`` API, as the write-through semantics needed for "
"trace hook support are always provided by the ``f_locals`` attribute on "
"frame objects, rather than being runtime state dependent."
msgstr ""

#: ../pep-0558.rst:115
msgid "New ``locals()`` documentation"
msgstr ""

#: ../pep-0558.rst:117
msgid ""
"The heart of this proposal is to revise the documentation for the "
"``locals()`` builtin to read as follows:"
msgstr ""

#: ../pep-0558.rst:120
msgid ""
"Return a mapping object representing the current local symbol table, with "
"variable names as the keys, and their currently bound references as the "
"values."
msgstr ""

#: ../pep-0558.rst:124 ../pep-0558.rst:195
msgid ""
"At module scope, as well as when using ``exec()`` or ``eval()`` with a "
"single namespace, this function returns the same namespace as ``globals()``."
msgstr ""

#: ../pep-0558.rst:127 ../pep-0558.rst:232
msgid ""
"At class scope, it returns the namespace that will be passed to the "
"metaclass constructor."
msgstr ""

#: ../pep-0558.rst:130
msgid ""
"When using ``exec()`` or ``eval()`` with separate local and global "
"namespaces, it returns the local namespace passed in to the function call."
msgstr ""

#: ../pep-0558.rst:133
msgid ""
"In all of the above cases, each call to ``locals()`` in a given frame of "
"execution will return the *same* mapping object. Changes made through the "
"mapping object returned from ``locals()`` will be visible as bound, rebound, "
"or deleted local variables, and binding, rebinding, or deleting local "
"variables will immediately affect the contents of the returned mapping "
"object."
msgstr ""

#: ../pep-0558.rst:140 ../pep-0558.rst:253
msgid ""
"At function scope (including for generators and coroutines), each call to "
"``locals()`` instead returns a fresh dictionary containing the current "
"bindings of the function's local variables and any nonlocal cell references. "
"In this case, name binding changes made via the returned dict are *not* "
"written back to the corresponding local variables or nonlocal cell "
"references, and binding, rebinding, or deleting local variables and nonlocal "
"cell references does *not* affect the contents of previously returned "
"dictionaries."
msgstr ""

#: ../pep-0558.rst:150
msgid ""
"There would also be a ``versionchanged`` note for the release making this "
"change:"
msgstr ""

#: ../pep-0558.rst:152
msgid ""
"In prior versions, the semantics of mutating the mapping object returned "
"from ``locals()`` were formally undefined. In CPython specifically, the "
"mapping returned at function scope could be implicitly refreshed by other "
"operations, such as calling ``locals()`` again, or the interpreter "
"implicitly invoking a Python level trace function. Obtaining the legacy "
"CPython behaviour now requires explicit calls to update the initially "
"returned dictionary with the results of subsequent calls to ``locals()``."
msgstr ""

#: ../pep-0558.rst:161
msgid ""
"For reference, the current documentation of this builtin reads as follows:"
msgstr ""

#: ../pep-0558.rst:163
msgid ""
"Update and return a dictionary representing the current local symbol table. "
"Free variables are returned by locals() when it is called in function "
"blocks, but not in class blocks."
msgstr ""

#: ../pep-0558.rst:167
msgid ""
"Note: The contents of this dictionary should not be modified; changes may "
"not affect the values of local and free variables used by the interpreter."
msgstr ""

#: ../pep-0558.rst:170
msgid ""
"(In other words: the status quo is that the semantics and behaviour of "
"``locals()`` are formally implementation defined, whereas the proposed state "
"after this PEP is that the only implementation defined behaviour will be "
"that associated with whether or not the implementation emulates the CPython "
"frame API, with the behaviour in all other cases being defined by the "
"language and library references)"
msgstr ""

#: ../pep-0558.rst:179
msgid "Module scope"
msgstr ""

#: ../pep-0558.rst:181
msgid ""
"At module scope, as well as when using ``exec()`` or ``eval()`` with a "
"single namespace, ``locals()`` must return the same object as ``globals()``, "
"which must be the actual execution namespace (available as ``inspect."
"currentframe().f_locals`` in implementations that provide access to frame "
"objects)."
msgstr ""

#: ../pep-0558.rst:187
msgid ""
"Variable assignments during subsequent code execution in the same scope must "
"dynamically change the contents of the returned mapping, and changes to the "
"returned mapping must change the values bound to local variable names in the "
"execution environment."
msgstr ""

#: ../pep-0558.rst:192
msgid ""
"To capture this expectation as part of the language specification, the "
"following paragraph will be added to the documentation for ``locals()``:"
msgstr ""

#: ../pep-0558.rst:198 ../pep-0558.rst:235
msgid ""
"This part of the proposal does not require any changes to the reference "
"implementation - it is standardisation of the current behaviour."
msgstr ""

#: ../pep-0558.rst:203
msgid "Class scope"
msgstr ""

#: ../pep-0558.rst:205
msgid ""
"At class scope, as well as when using ``exec()`` or ``eval()`` with separate "
"global and local namespaces, ``locals()`` must return the specified local "
"namespace (which may be supplied by the metaclass ``__prepare__`` method in "
"the case of classes). As for module scope, this must be a direct reference "
"to the actual execution namespace (available as ``inspect.currentframe()."
"f_locals`` in implementations that provide access to frame objects)."
msgstr ""

#: ../pep-0558.rst:213
msgid ""
"Variable assignments during subsequent code execution in the same scope must "
"change the contents of the returned mapping, and changes to the returned "
"mapping must change the values bound to local variable names in the "
"execution environment."
msgstr ""

#: ../pep-0558.rst:218
msgid ""
"The mapping returned by ``locals()`` will *not* be used as the actual class "
"namespace underlying the defined class (the class creation process will copy "
"the contents to a fresh dictionary that is only accessible by going through "
"the class machinery)."
msgstr ""

#: ../pep-0558.rst:223
msgid ""
"For nested classes defined inside a function, any nonlocal cells referenced "
"from the class scope are *not* included in the ``locals()`` mapping."
msgstr ""

#: ../pep-0558.rst:226
msgid ""
"To capture this expectation as part of the language specification, the "
"following two paragraphs will be added to the documentation for ``locals()``:"
msgstr ""

#: ../pep-0558.rst:229
msgid ""
"When using ``exec()`` or ``eval()`` with separate local and global "
"namespaces, [this function] returns the given local namespace."
msgstr ""

#: ../pep-0558.rst:240
msgid "Function scope"
msgstr ""

#: ../pep-0558.rst:242
msgid ""
"At function scope, interpreter implementations are granted significant "
"freedom to optimise local variable access, and hence are NOT required to "
"permit arbitrary modification of local and nonlocal variable bindings "
"through the mapping returned from ``locals()``."
msgstr ""

#: ../pep-0558.rst:247
msgid ""
"Historically, this leniency has been described in the language specification "
"with the words \"The contents of this dictionary should not be modified; "
"changes may not affect the values of local and free variables used by the "
"interpreter.\""
msgstr ""

#: ../pep-0558.rst:251
msgid "This PEP proposes to change that text to instead say:"
msgstr ""

#: ../pep-0558.rst:262
msgid ""
"This part of the proposal *does* require changes to the CPython reference "
"implementation, as CPython currently returns a shared mapping object that "
"may be implicitly refreshed by additional calls to ``locals()``, and the "
"\"write back\" strategy currently used to support namespace changes from "
"trace functions also doesn't comply with it (and causes the quirky "
"behavioural problems mentioned in the Motivation above)."
msgstr ""

#: ../pep-0558.rst:271
msgid "CPython Implementation Changes"
msgstr ""

#: ../pep-0558.rst:274
msgid "Summary of proposed implementation-specific changes"
msgstr ""

#: ../pep-0558.rst:276
msgid ""
"Changes are made as necessary to provide the updated Python level semantics"
msgstr ""

#: ../pep-0558.rst:277
msgid ""
"Two new functions are added to the stable ABI to replicate the updated "
"behaviour of the Python ``locals()`` builtin:"
msgstr ""

#: ../pep-0558.rst:285
msgid ""
"One new function is added to the stable ABI to efficiently get a snapshot of "
"the local namespace in the running frame:"
msgstr ""

#: ../pep-0558.rst:292
msgid ""
"Corresponding frame accessor functions for these new public APIs are added "
"to the CPython frame C API"
msgstr ""

#: ../pep-0558.rst:294
msgid ""
"On optimised frames, the Python level ``f_locals`` API will return "
"dynamically created read/write proxy objects that directly access the "
"frame's local and closure variable storage. To provide interoperability with "
"the existing ``PyEval_GetLocals()`` API, the proxy objects will continue to "
"use the C level frame locals data storage field to hold a value cache that "
"also allows for storage of arbitrary additional keys. Additional details on "
"the expected behaviour of these fast locals proxy objects are covered below."
msgstr ""

#: ../pep-0558.rst:301
msgid ""
"No C API function is added to get access to a mutable mapping for the local "
"namespace. Instead, ``PyObject_GetAttrString(frame, \"f_locals\")`` is used, "
"the same API as is used in Python code."
msgstr ""

#: ../pep-0558.rst:304
msgid ""
"``PyEval_GetLocals()`` remains supported and does not emit a programmatic "
"warning, but will be deprecated in the documentation in favour of the new "
"APIs that don't rely on returning a borrowed reference"
msgstr ""

#: ../pep-0558.rst:307
msgid ""
"``PyFrame_FastToLocals()`` and ``PyFrame_FastToLocalsWithError()`` remain "
"supported and do not emit a programmatic warning, but will be deprecated in "
"the documentation in favour of the new APIs that don't require direct access "
"to the internal data storage layout of frame objects"
msgstr ""

#: ../pep-0558.rst:311
msgid ""
"``PyFrame_LocalsToFast()`` always raises ``RuntimeError()``, indicating that "
"``PyObject_GetAttrString(frame, \"f_locals\")`` should be used to obtain a "
"mutable read/write mapping for the local variables."
msgstr ""

#: ../pep-0558.rst:314
msgid ""
"The trace hook implementation will no longer call ``PyFrame_FastToLocals()`` "
"implicitly. The version porting guide will recommend migrating to "
"``PyFrame_GetLocals()`` for read-only access and "
"``PyObject_GetAttrString(frame, \"f_locals\")`` for read/write access."
msgstr ""

#: ../pep-0558.rst:321
msgid "Providing the updated Python level semantics"
msgstr ""

#: ../pep-0558.rst:323
msgid ""
"The implementation of the ``locals()`` builtin is modified to return a "
"distinct copy of the local namespace for optimised frames, rather than a "
"direct reference to the internal frame value cache updated by the "
"``PyFrame_FastToLocals()`` C API and returned by the ``PyEval_GetLocals()`` "
"C API."
msgstr ""

#: ../pep-0558.rst:330
msgid "Resolving the issues with tracing mode behaviour"
msgstr ""

#: ../pep-0558.rst:332
msgid ""
"The current cause of CPython's tracing mode quirks (both the side effects "
"from simply installing a tracing function and the fact that writing values "
"back to function locals only works for the specific function being traced) "
"is the way that locals mutation support for trace hooks is currently "
"implemented: the ``PyFrame_LocalsToFast`` function."
msgstr ""

#: ../pep-0558.rst:338
msgid ""
"When a trace function is installed, CPython currently does the following for "
"function frames (those where the code object uses \"fast locals\" semantics):"
msgstr ""

#: ../pep-0558.rst:341
msgid "Calls ``PyFrame_FastToLocals`` to update the frame value cache"
msgstr ""

#: ../pep-0558.rst:342
msgid "Calls the trace hook (with tracing of the hook itself disabled)"
msgstr ""

#: ../pep-0558.rst:343
msgid ""
"Calls ``PyFrame_LocalsToFast`` to capture any changes made to the frame "
"value cache"
msgstr ""

#: ../pep-0558.rst:346
msgid "This approach is problematic for a few different reasons:"
msgstr ""

#: ../pep-0558.rst:348
msgid ""
"Even if the trace function doesn't mutate the value cache, the final step "
"resets any cell references back to the state they were in before the trace "
"function was called (this is the root cause of the bug report in [1]_)"
msgstr ""

#: ../pep-0558.rst:351
msgid ""
"If the trace function *does* mutate the value cache, but then does something "
"that causes the value cache to be refreshed from the frame, those changes "
"are lost (this is one aspect of the bug report in [3]_)"
msgstr ""

#: ../pep-0558.rst:354
msgid ""
"If the trace function attempts to mutate the local variables of a frame "
"other than the one being traced (e.g. ``frame.f_back.f_locals``), those "
"changes will almost certainly be lost (this is another aspect of the bug "
"report in [3]_)"
msgstr ""

#: ../pep-0558.rst:358
msgid ""
"If a reference to the frame value cache (e.g. retrieved via ``locals()``) is "
"passed to another function, and *that* function mutates the value cache, "
"then those changes *may* be written back to the execution frame *if* a trace "
"hook is installed"
msgstr ""

#: ../pep-0558.rst:363
msgid ""
"The proposed resolution to this problem is to take advantage of the fact "
"that whereas functions typically access their *own* namespace using the "
"language defined ``locals()`` builtin, trace functions necessarily use the "
"implementation dependent ``frame.f_locals`` interface, as a frame reference "
"is what gets passed to hook implementations."
msgstr ""

#: ../pep-0558.rst:369
msgid ""
"Instead of being a direct reference to the internal frame value cache "
"historically returned by the ``locals()`` builtin, the Python level ``frame."
"f_locals`` will be updated to instead return instances of a dedicated fast "
"locals proxy type that writes and reads values directly to and from the fast "
"locals array on the underlying frame. Each access of the attribute produces "
"a new instance of the proxy (so creating proxy instances is intentionally a "
"cheap operation)."
msgstr ""

#: ../pep-0558.rst:376
msgid ""
"Despite the new proxy type becoming the preferred way to access local "
"variables on optimised frames, the internal value cache stored on the frame "
"is still retained for two key purposes:"
msgstr ""

#: ../pep-0558.rst:380
msgid ""
"maintaining backwards compatibility for and interoperability with the "
"``PyEval_GetLocals()`` C API"
msgstr ""

#: ../pep-0558.rst:382
msgid ""
"providing storage space for additional keys that don't have slots in the "
"fast locals array (e.g. the ``__return__`` and ``__exception__`` keys set by "
"``pdb`` when tracing code execution for debugging purposes)"
msgstr ""

#: ../pep-0558.rst:387
msgid ""
"With the changes in this PEP, this internal frame value cache is no longer "
"directly accessible from Python code (whereas historically it was both "
"returned by the ``locals()`` builtin and available as the ``frame.f_locals`` "
"attribute). Instead, the value cache is only accessible via the "
"``PyEval_GetLocals()`` C API and by directly accessing the internal storage "
"of a frame object."
msgstr ""

#: ../pep-0558.rst:394
msgid ""
"Fast locals proxy objects and the internal frame value cache returned by "
"``PyEval_GetLocals()`` offer the following behavioural guarantees:"
msgstr ""

#: ../pep-0558.rst:397
msgid ""
"changes made via a fast locals proxy will be immediately visible to the "
"frame itself, to other fast locals proxy objects for the same frame, and in "
"the internal value cache stored on the frame (it is this last point that "
"provides ``PyEval_GetLocals()`` interoperability)"
msgstr ""

#: ../pep-0558.rst:401
msgid ""
"changes made directly to the internal frame value cache will never be "
"visible to the frame itself, and will only be reliably visible via fast "
"locals proxies for the same frame if the change relates to extra variables "
"that don't have slots in the frame's fast locals array"
msgstr ""

#: ../pep-0558.rst:405
msgid ""
"changes made by executing code in the frame will be immediately visible to "
"all fast locals proxy objects for that frame (both existing proxies and "
"newly created ones). Visibility in the internal frame value cache cache "
"returned by ``PyEval_GetLocals()`` is subject to the cache update guidelines "
"discussed in the next section"
msgstr ""

#: ../pep-0558.rst:411
msgid ""
"As a result of these points, only code using ``PyEval_GetLocals()``, "
"``PyLocals_Get()``, or ``PyLocals_GetCopy()`` will need to be concerned "
"about the frame value cache potentially becoming stale. Code using the new "
"frame fast locals proxy API (whether from Python or from C) will always see "
"the live state of the frame."
msgstr ""

#: ../pep-0558.rst:419
msgid "Fast locals proxy implementation details"
msgstr ""

#: ../pep-0558.rst:421
msgid ""
"Each fast locals proxy instance has a single internal attribute that is not "
"exposed as part of the Python runtime API:"
msgstr ""

#: ../pep-0558.rst:424
msgid ""
"*frame*: the underlying optimised frame that the proxy provides access to"
msgstr ""

#: ../pep-0558.rst:426
msgid ""
"In addition, proxy instances use and update the following attributes stored "
"on the underlying frame or code object:"
msgstr ""

#: ../pep-0558.rst:429
msgid ""
"*_name_to_offset_mapping*: a hidden mapping from variable names to fast "
"local storage offsets. This mapping is lazily initialized on the first frame "
"read or write access through a fast locals proxy, rather than being eagerly "
"populated as soon as the first fast locals proxy is created. Since the "
"mapping is identical for all frames running a given code object, a single "
"copy is stored on the code object, rather than each frame object populating "
"its own mapping"
msgstr ""

#: ../pep-0558.rst:435
msgid ""
"*locals*: the internal frame value cache returned by the "
"``PyEval_GetLocals()`` C API and updated by the ``PyFrame_FastToLocals()`` C "
"API. This is the mapping that the ``locals()`` builtin returns in Python "
"3.10 and earlier."
msgstr ""

#: ../pep-0558.rst:439
msgid ""
"``__getitem__`` operations on the proxy will populate the "
"``_name_to_offset_mapping`` on the code object (if it is not already "
"populated), and then either return the relevant value (if the key is found "
"in either the ``_name_to_offset_mapping`` mapping or the internal frame "
"value cache), or else raise ``KeyError``. Variables that are defined on the "
"frame but not currently bound also raise ``KeyError`` (just as they're "
"omitted from the result of ``locals()``)."
msgstr ""

#: ../pep-0558.rst:446
msgid ""
"As the frame storage is always accessed directly, the proxy will "
"automatically pick up name binding and unbinding operations that take place "
"as the function executes. The internal value cache is implicitly updated "
"when individual variables are read from the frame state (including for "
"containment checks, which need to check if the name is currently bound or "
"unbound)."
msgstr ""

#: ../pep-0558.rst:452
msgid ""
"Similarly, ``__setitem__`` and ``__delitem__`` operations on the proxy will "
"directly affect the corresponding fast local or cell reference on the "
"underlying frame, ensuring that changes are immediately visible to the "
"running Python code, rather than needing to be written back to the runtime "
"storage at some later time. Such changes are also immediately written to the "
"internal frame value cache to make them visible to users of the "
"``PyEval_GetLocals()`` C API."
msgstr ""

#: ../pep-0558.rst:459
msgid ""
"Keys that are not defined as local or closure variables on the underlying "
"frame are still written to the internal value cache on optimised frames. "
"This allows utilities like ``pdb`` (which writes ``__return__`` and "
"``__exception__`` values into the frame's ``f_locals`` mapping) to continue "
"working as they always have. These additional keys that do not correspond to "
"a local or closure variable on the frame will be left alone by future cache "
"sync operations. Using the frame value cache to store these extra keys "
"(rather than defining a new mapping that holds only the extra keys) provides "
"full interoperability with the existing ``PyEval_GetLocals()`` API (since "
"users of either API will see extra keys added by users of either API, rather "
"than users of the new fast locals proxy API only seeing keys added via that "
"API)."
msgstr ""

#: ../pep-0558.rst:471
msgid ""
"An additional benefit of storing only the variable value cache on the frame "
"(rather than storing an instance of the proxy type), is that it avoids "
"creating a reference cycle from the frame back to itself, so the frame will "
"only be kept alive if another object retains a reference to a proxy instance."
msgstr ""

#: ../pep-0558.rst:476
msgid ""
"Note: calling the ``proxy.clear()`` method has a similarly broad impact as "
"calling ``PyFrame_LocalsToFast()`` on an empty frame value cache in earlier "
"versions. Not only will the frame local variables be cleared, but also any "
"cell variables accessible from the frame (whether those cells are owned by "
"the frame itself or by an outer frame). This *can* clear a class's "
"``__class__`` cell if called on the frame of a method that uses the zero-arg "
"``super()`` construct (or otherwise references ``__class__``). This exceeds "
"the scope of calling ``frame.clear()``, as that only drop's the frame's "
"references to cell variables, it doesn't clear the cells themselves. This "
"PEP could be a potential opportunity to narrow the scope of attempts to "
"clear the frame variables directly by leaving cells belonging to outer "
"frames alone, and only clearing local variables and cells belonging directly "
"to the frame underlying the proxy (this issue affects :pep:`667` as well, as "
"the question relates to the handling of cell variables, and is entirely "
"independent of the internal frame value cache)."
msgstr ""

#: ../pep-0558.rst:493
msgid "Changes to the stable C API/ABI"
msgstr ""

#: ../pep-0558.rst:495
msgid ""
"Unlike Python code, extension module functions that call in to the Python C "
"API can be called from any kind of Python scope. This means it isn't obvious "
"from the context whether ``locals()`` will return a snapshot or not, as it "
"depends on the scope of the calling Python code, not the C code itself."
msgstr ""

#: ../pep-0558.rst:500
msgid ""
"This means it is desirable to offer C APIs that give predictable, scope "
"independent, behaviour. However, it is also desirable to allow C code to "
"exactly mimic the behaviour of Python code at the same scope."
msgstr ""

#: ../pep-0558.rst:504
msgid ""
"To enable mimicking the behaviour of Python code, the stable C ABI would "
"gain the following new functions:"
msgstr ""

#: ../pep-0558.rst:512
msgid ""
"``PyLocals_Get()`` is directly equivalent to the Python ``locals()`` "
"builtin. It returns a new reference to the local namespace mapping for the "
"active Python frame at module and class scope, and when using ``exec()`` or "
"``eval()``. It returns a shallow copy of the active namespace at function/"
"coroutine/generator scope."
msgstr ""

#: ../pep-0558.rst:518
msgid ""
"``PyLocals_GetKind()`` returns a value from the newly defined "
"``PyLocals_Kind`` enum, with the following options being available:"
msgstr ""

#: ../pep-0558.rst:521
msgid ""
"``PyLocals_DIRECT_REFERENCE``: ``PyLocals_Get()`` returns a direct reference "
"to the local namespace for the running frame."
msgstr ""

#: ../pep-0558.rst:523
msgid ""
"``PyLocals_SHALLOW_COPY``: ``PyLocals_Get()`` returns a shallow copy of the "
"local namespace for the running frame."
msgstr ""

#: ../pep-0558.rst:525
msgid ""
"``PyLocals_UNDEFINED``: an error occurred (e.g. no active Python thread "
"state). A Python exception will be set if this value is returned."
msgstr ""

#: ../pep-0558.rst:528
msgid ""
"Since the enum is used in the stable ABI, an additional 31-bit value is set "
"to ensure that it is safe to cast arbitrary signed 32-bit signed integers to "
"``PyLocals_Kind`` values."
msgstr ""

#: ../pep-0558.rst:532
msgid ""
"This query API allows extension module code to determine the potential "
"impact of mutating the mapping returned by ``PyLocals_Get()`` without "
"needing access to the details of the running frame object. Python code gets "
"equivalent information visually through lexical scoping (as covered in the "
"new ``locals()`` builtin documentation)."
msgstr ""

#: ../pep-0558.rst:538
msgid ""
"To allow extension module code to behave consistently regardless of the "
"active Python scope, the stable C ABI would gain the following new function:"
msgstr ""

#: ../pep-0558.rst:545
msgid ""
"``PyLocals_GetCopy()`` returns a new dict instance populated from the "
"current locals namespace. Roughly equivalent to ``dict(locals())`` in Python "
"code, but avoids the double-copy in the case where ``locals()`` already "
"returns a shallow copy. Akin to the following code, but doesn't assume there "
"will only ever be two kinds of locals result:"
msgstr ""

#: ../pep-0558.rst:558
msgid ""
"The existing ``PyEval_GetLocals()`` API will retain its existing behaviour "
"in CPython (mutable locals at class and module scope, shared dynamic "
"snapshot otherwise). However, its documentation will be updated to note that "
"the conditions under which the shared dynamic snapshot get updated have "
"changed."
msgstr ""

#: ../pep-0558.rst:563
msgid ""
"The ``PyEval_GetLocals()`` documentation will also be updated to recommend "
"replacing usage of this API with whichever of the new APIs is most "
"appropriate for the use case:"
msgstr ""

#: ../pep-0558.rst:567
msgid ""
"Use ``PyLocals_Get()`` (optionally combined with ``PyDictProxy_New()``) for "
"read-only access to the current locals namespace. This form of usage will "
"need to be aware that the copy may go stale in optimised frames."
msgstr ""

#: ../pep-0558.rst:570
msgid ""
"Use ``PyLocals_GetCopy()`` for a regular mutable dict that contains a copy "
"of the current locals namespace, but has no ongoing connection to the active "
"frame."
msgstr ""

#: ../pep-0558.rst:573
msgid ""
"Use ``PyLocals_Get()`` to exactly match the semantics of the Python level "
"``locals()`` builtin."
msgstr ""

#: ../pep-0558.rst:575
msgid ""
"Query ``PyLocals_GetKind()`` explicitly to implement custom handling (e.g. "
"raising a meaningful exception) for scopes where ``PyLocals_Get()`` would "
"return a shallow copy rather than granting read/write access to the locals "
"namespace."
msgstr ""

#: ../pep-0558.rst:579
msgid ""
"Use implementation specific APIs (e.g. ``PyObject_GetAttrString(frame, "
"\"f_locals\")``) if read/write access to the frame is required and "
"``PyLocals_GetKind()`` returns something other than "
"``PyLocals_DIRECT_REFERENCE``."
msgstr ""

#: ../pep-0558.rst:585
msgid "Changes to the public CPython C API"
msgstr ""

#: ../pep-0558.rst:587
msgid ""
"The existing ``PyEval_GetLocals()`` API returns a borrowed reference, which "
"means it cannot be updated to return the new shallow copies at function "
"scope. Instead, it will continue to return a borrowed reference to an "
"internal dynamic snapshot stored on the frame object. This shared mapping "
"will behave similarly to the existing shared mapping in Python 3.10 and "
"earlier, but the exact conditions under which it gets refreshed will be "
"different. Specifically, it will be updated only in the following "
"circumstance:"
msgstr ""

#: ../pep-0558.rst:595
msgid ""
"any call to ``PyEval_GetLocals()``, ``PyLocals_Get()``, "
"``PyLocals_GetCopy()``, or the Python ``locals()`` builtin while the frame "
"is running"
msgstr ""

#: ../pep-0558.rst:597
msgid ""
"any call to ``PyFrame_GetLocals()``, ``PyFrame_GetLocalsCopy()``, "
"``_PyFrame_BorrowLocals()``, ``PyFrame_FastToLocals()``, or "
"``PyFrame_FastToLocalsWithError()`` for the frame"
msgstr ""

#: ../pep-0558.rst:600
msgid ""
"any operation on a fast locals proxy object that updates the shared mapping "
"as part of its implementation. In the initial reference implementation, "
"those operations are those that are intrinsically ``O(n)`` operations "
"(``len(flp)``, mapping comparison, ``flp.copy()`` and rendering as a "
"string), as well as those that refresh the cache entries for individual keys."
msgstr ""

#: ../pep-0558.rst:606
msgid ""
"Requesting a fast locals proxy will *not* implicitly update the shared "
"dynamic snapshot, and the CPython trace hook handling will no longer "
"implicitly update it either."
msgstr ""

#: ../pep-0558.rst:610
msgid ""
"(Note: even though ``PyEval_GetLocals()`` is part of the stable C API/ABI, "
"the specifics of when the namespace it returns gets refreshed are still an "
"interpreter implementation detail)"
msgstr ""

#: ../pep-0558.rst:614
msgid ""
"The additions to the public CPython C API are the frame level enhancements "
"needed to support the stable C API/ABI updates:"
msgstr ""

#: ../pep-0558.rst:625
msgid ""
"``PyFrame_GetLocalsKind(frame)`` is the underlying API for "
"``PyLocals_GetKind()``."
msgstr ""

#: ../pep-0558.rst:628
msgid ""
"``PyFrame_GetLocals(frame)`` is the underlying API for ``PyLocals_Get()``."
msgstr ""

#: ../pep-0558.rst:630
msgid ""
"``PyFrame_GetLocalsCopy(frame)`` is the underlying API for "
"``PyLocals_GetCopy()``."
msgstr ""

#: ../pep-0558.rst:633
msgid ""
"``_PyFrame_BorrowLocals(frame)`` is the underlying API for "
"``PyEval_GetLocals()``. The underscore prefix is intended to discourage use "
"and to indicate that code using it is unlikely to be portable across "
"implementations. However, it is documented and visible to the linker in "
"order to avoid having to access the internals of the frame struct from the "
"``PyEval_GetLocals()`` implementation."
msgstr ""

#: ../pep-0558.rst:640
msgid ""
"The ``PyFrame_LocalsToFast()`` function will be changed to always emit "
"``RuntimeError``, explaining that it is no longer a supported operation, and "
"affected code should be updated to use ``PyObject_GetAttrString(frame, "
"\"f_locals\")`` to obtain a read/write proxy instead."
msgstr ""

#: ../pep-0558.rst:646
msgid ""
"In addition to the above documented interfaces, the draft reference "
"implementation also exposes the following undocumented interfaces:"
msgstr ""

#: ../pep-0558.rst:654
msgid ""
"This type is what the reference implementation actually returns from "
"``PyObject_GetAttrString(frame, \"f_locals\")`` for optimized frames (i.e. "
"when ``PyFrame_GetLocalsKind()`` returns ``PyLocals_SHALLOW_COPY``)."
msgstr ""

#: ../pep-0558.rst:660
msgid "Reducing the runtime overhead of trace hooks"
msgstr ""

#: ../pep-0558.rst:662
msgid ""
"As noted in [9]_, the implicit call to ``PyFrame_FastToLocals()`` in the "
"Python trace hook support isn't free, and could be rendered unnecessary if "
"the frame proxy read values directly from the frame instead of getting them "
"from the mapping."
msgstr ""

#: ../pep-0558.rst:667
msgid ""
"As the new frame locals proxy type doesn't require separate data refresh "
"steps, this PEP incorporates Victor Stinner's proposal to no longer "
"implicitly call ``PyFrame_FastToLocalsWithError()`` before calling trace "
"hooks implemented in Python."
msgstr ""

#: ../pep-0558.rst:672
msgid ""
"Code using the new fast locals proxy objects will have the dynamic locals "
"snapshot implicitly refreshed when accessing methods that need it, while "
"code using the ``PyEval_GetLocals()`` API will implicitly refresh it when "
"making that call."
msgstr ""

#: ../pep-0558.rst:676
msgid ""
"The PEP necessarily also drops the implicit call to "
"``PyFrame_LocalsToFast()`` when returning from a trace hook, as that API now "
"always raises an exception."
msgstr ""

#: ../pep-0558.rst:681
msgid "Rationale and Design Discussion"
msgstr ""

#: ../pep-0558.rst:684
msgid "Changing ``locals()`` to return independent snapshots at function scope"
msgstr ""

#: ../pep-0558.rst:686
msgid ""
"The ``locals()`` builtin is a required part of the language, and in the "
"reference implementation it has historically returned a mutable mapping with "
"the following characteristics:"
msgstr ""

#: ../pep-0558.rst:690
msgid "each call to ``locals()`` returns the *same* mapping object"
msgstr ""

#: ../pep-0558.rst:691
msgid ""
"for namespaces where ``locals()`` returns a reference to something other "
"than the actual local execution namespace, each call to ``locals()`` updates "
"the mapping object with the current state of the local variables and any "
"referenced nonlocal cells"
msgstr ""

#: ../pep-0558.rst:695
msgid ""
"changes to the returned mapping *usually* aren't written back to the local "
"variable bindings or the nonlocal cell references, but write backs can be "
"triggered by doing one of the following:"
msgstr ""

#: ../pep-0558.rst:699
msgid ""
"installing a Python level trace hook (write backs then happen whenever the "
"trace hook is called)"
msgstr ""

#: ../pep-0558.rst:701
msgid ""
"running a function level wildcard import (requires bytecode injection in Py3)"
msgstr ""

#: ../pep-0558.rst:702
msgid ""
"running an ``exec`` statement in the function's scope (Py2 only, since "
"``exec`` became an ordinary builtin in Python 3)"
msgstr ""

#: ../pep-0558.rst:705
msgid ""
"Originally this PEP proposed to retain the first two of these properties, "
"while changing the third in order to address the outright behaviour bugs "
"that it can cause."
msgstr ""

#: ../pep-0558.rst:709
msgid ""
"In [7]_ Nathaniel Smith made a persuasive case that we could make the "
"behaviour of ``locals()`` at function scope substantially less confusing by "
"retaining only the second property and having each call to ``locals()`` at "
"function scope return an *independent* snapshot of the local variables and "
"closure references rather than updating an implicitly shared snapshot."
msgstr ""

#: ../pep-0558.rst:715
msgid ""
"As this revised design also made the implementation markedly easier to "
"follow, the PEP was updated to propose this change in behaviour, rather than "
"retaining the historical shared snapshot."
msgstr ""

#: ../pep-0558.rst:721
msgid "Keeping ``locals()`` as a snapshot at function scope"
msgstr ""

#: ../pep-0558.rst:723
msgid ""
"As discussed in [7]_, it would theoretically be possible to change the "
"semantics of the ``locals()`` builtin to return the write-through proxy at "
"function scope, rather than switching it to return independent snapshots."
msgstr ""

#: ../pep-0558.rst:727
msgid ""
"This PEP doesn't (and won't) propose this as it's a backwards incompatible "
"change in practice, even though code that relies on the current behaviour is "
"technically operating in an undefined area of the language specification."
msgstr ""

#: ../pep-0558.rst:731
msgid "Consider the following code snippet::"
msgstr ""

#: ../pep-0558.rst:738
msgid ""
"Even with a trace hook installed, that function will consistently print "
"``1`` on the current reference interpreter implementation::"
msgstr ""

#: ../pep-0558.rst:751
msgid ""
"Similarly, ``locals()`` can be passed to the ``exec()`` and ``eval()`` "
"builtins at function scope (either explicitly or implicitly) without risking "
"unexpected rebinding of local variables or closure references."
msgstr ""

#: ../pep-0558.rst:755
msgid ""
"Provoking the reference interpreter into incorrectly mutating the local "
"variable state requires a more complex setup where a nested function closes "
"over a variable being rebound in the outer function, and due to the use of "
"either threads, generators, or coroutines, it's possible for a trace "
"function to start running for the nested function before the rebinding "
"operation in the outer function, but finish running after the rebinding "
"operation has taken place (in which case the rebinding will be reverted, "
"which is the bug reported in [1]_)."
msgstr ""

#: ../pep-0558.rst:763
msgid ""
"In addition to preserving the de facto semantics which have been in place "
"since :pep:`227` introduced nested scopes in Python 2.1, the other benefit "
"of restricting the write-through proxy support to the implementation-defined "
"frame object API is that it means that only interpreter implementations "
"which emulate the full frame API need to offer the write-through capability "
"at all, and that JIT-compiled implementations only need to enable it when a "
"frame introspection API is invoked, or a trace hook is installed, not "
"whenever ``locals()`` is accessed at function scope."
msgstr ""

#: ../pep-0558.rst:772
msgid ""
"Returning snapshots from ``locals()`` at function scope also means that "
"static analysis for function level code will be more reliable, as only "
"access to the frame machinery will allow rebinding of local and nonlocal "
"variable references in a way that is hidden from static analysis."
msgstr ""

#: ../pep-0558.rst:779
msgid "Retaining the internal frame value cache"
msgstr ""

#: ../pep-0558.rst:781
msgid ""
"Retaining the internal frame value cache results in some visible quirks when "
"frame proxy instances are kept around and re-used after name binding and "
"unbinding operations have been executed on the frame."
msgstr ""

#: ../pep-0558.rst:785
msgid ""
"The primary reason for retaining the frame value cache is to maintain "
"backwards compatibility with the ``PyEval_GetLocals()`` API. That API "
"returns a borrowed reference, so it must refer to persistent state stored on "
"the frame object. Storing a fast locals proxy object on the frame creates a "
"problematic reference cycle, so the cleanest option is to instead continue "
"to return a frame value cache, just as this function has done since "
"optimised frames were first introduced."
msgstr ""

#: ../pep-0558.rst:793
msgid ""
"With the frame value cache being kept around anyway, it then further made "
"sense to rely on it to simplify the fast locals proxy mapping implementation."
msgstr ""

#: ../pep-0558.rst:798
msgid "What happens with the default args for ``eval()`` and ``exec()``?"
msgstr ""

#: ../pep-0558.rst:800
msgid ""
"These are formally defined as inheriting ``globals()`` and ``locals()`` from "
"the calling scope by default."
msgstr ""

#: ../pep-0558.rst:803
msgid ""
"There isn't any need for the PEP to change these defaults, so it doesn't, "
"and ``exec()`` and ``eval()`` will start running in a shallow copy of the "
"local namespace when that is what ``locals()`` returns."
msgstr ""

#: ../pep-0558.rst:807
msgid ""
"This behaviour will have potential performance implications, especially for "
"functions with large numbers of local variables (e.g. if these functions are "
"called in a loop, calling ``globals()`` and ``locals()`` once before the "
"loop and then passing the namespace into the function explicitly will give "
"the same semantics and performance characteristics as the status quo, "
"whereas relying on the implicit default would create a new shallow copy of "
"the local namespace on each iteration)."
msgstr ""

#: ../pep-0558.rst:815
msgid ""
"(Note: the reference implementation draft PR has updated the ``locals()`` "
"and ``vars()``, ``eval()``, and ``exec()`` builtins to use "
"``PyLocals_Get()``. The ``dir()`` builtin still uses ``PyEval_GetLocals()``, "
"since it's only using it to make a list from the keys)."
msgstr ""

#: ../pep-0558.rst:822
msgid "Changing the frame API semantics in regular operation"
msgstr ""

#: ../pep-0558.rst:824
msgid ""
"Earlier versions of this PEP proposed having the semantics of the frame "
"``f_locals`` attribute depend on whether or not a tracing hook was currently "
"installed - only providing the write-through proxy behaviour when a tracing "
"hook was active, and otherwise behaving the same as the historical "
"``locals()`` builtin."
msgstr ""

#: ../pep-0558.rst:830
msgid ""
"That was adopted as the original design proposal for a couple of key "
"reasons, one pragmatic and one more philosophical:"
msgstr ""

#: ../pep-0558.rst:833
msgid ""
"Object allocations and method wrappers aren't free, and tracing functions "
"aren't the only operations that access frame locals from outside the "
"function. Restricting the changes to tracing mode meant that the additional "
"memory and execution time overhead of these changes would be as close to "
"zero in regular operation as we can possibly make them."
msgstr ""

#: ../pep-0558.rst:838
msgid ""
"\"Don't change what isn't broken\": the current tracing mode problems are "
"caused by a requirement that's specific to tracing mode (support for "
"external rebinding of function local variable references), so it made sense "
"to also restrict any related fixes to tracing mode"
msgstr ""

#: ../pep-0558.rst:843
msgid ""
"However, actually attempting to implement and document that dynamic approach "
"highlighted the fact that it makes for a really subtle runtime state "
"dependent behaviour distinction in how ``frame.f_locals`` works, and creates "
"several new edge cases around how ``f_locals`` behaves as trace functions "
"are added and removed."
msgstr ""

#: ../pep-0558.rst:849
msgid ""
"Accordingly, the design was switched to the current one, where ``frame."
"f_locals`` is always a write-through proxy, and ``locals()`` is always a "
"snapshot, which is both simpler to implement and easier to explain."
msgstr ""

#: ../pep-0558.rst:853
msgid ""
"Regardless of how the CPython reference implementation chooses to handle "
"this, optimising compilers and interpreters also remain free to impose "
"additional restrictions on debuggers, such as making local variable mutation "
"through frame objects an opt-in behaviour that may disable some "
"optimisations (just as the emulation of CPython's frame API is already an "
"opt-in flag in some Python implementations)."
msgstr ""

#: ../pep-0558.rst:862
msgid "Continuing to support storing additional data on optimised frames"
msgstr ""

#: ../pep-0558.rst:864
msgid ""
"One of the draft iterations of this PEP proposed removing the ability to "
"store additional data on optimised frames by writing to ``frame.f_locals`` "
"keys that didn't correspond to local or closure variable names on the "
"underlying frame."
msgstr ""

#: ../pep-0558.rst:868
msgid ""
"While this idea offered some attractive simplification of the fast locals "
"proxy implementation, ``pdb`` stores ``__return__`` and ``__exception__`` "
"values on arbitrary frames, so the standard library test suite fails if that "
"functionality no longer works."
msgstr ""

#: ../pep-0558.rst:873
msgid ""
"Accordingly, the ability to store arbitrary keys was retained, at the "
"expense of certain operations on proxy objects being slower than could "
"otherwise be (since they can't assume that only names defined on the code "
"object will be accessible through the proxy)."
msgstr ""

#: ../pep-0558.rst:878
msgid ""
"It is expected that the exact details of the interaction between the fast "
"locals proxy and the ``f_locals`` value cache on the underlying frame will "
"evolve over time as opportunities for improvement are identified."
msgstr ""

#: ../pep-0558.rst:884
msgid "Historical semantics at function scope"
msgstr ""

#: ../pep-0558.rst:886
msgid ""
"The current semantics of mutating ``locals()`` and ``frame.f_locals`` in "
"CPython are rather quirky due to historical implementation details:"
msgstr ""

#: ../pep-0558.rst:889
msgid ""
"actual execution uses the fast locals array for local variable bindings and "
"cell references for nonlocal variables"
msgstr ""

#: ../pep-0558.rst:891
msgid ""
"there's a ``PyFrame_FastToLocals`` operation that populates the frame's "
"``f_locals`` attribute based on the current state of the fast locals array "
"and any referenced cells. This exists for three reasons:"
msgstr ""

#: ../pep-0558.rst:895
msgid "allowing trace functions to read the state of local variables"
msgstr ""

#: ../pep-0558.rst:896
msgid "allowing traceback processors to read the state of local variables"
msgstr ""

#: ../pep-0558.rst:897
msgid "allowing ``locals()`` to read the state of local variables"
msgstr ""

#: ../pep-0558.rst:898
msgid ""
"a direct reference to ``frame.f_locals`` is returned from ``locals()``, so "
"if you hand out multiple concurrent references, then all those references "
"will be to the exact same dictionary"
msgstr ""

#: ../pep-0558.rst:901
msgid ""
"the two common calls to the reverse operation, ``PyFrame_LocalsToFast``, "
"were removed in the migration to Python 3: ``exec`` is no longer a statement "
"(and hence can no longer affect function local namespaces), and the compiler "
"now disallows the use of ``from module import *`` operations at function "
"scope"
msgstr ""

#: ../pep-0558.rst:905
msgid ""
"however, two obscure calling paths remain: ``PyFrame_LocalsToFast`` is "
"called as part of returning from a trace function (which allows debuggers to "
"make changes to the local variable state), and you can also still inject the "
"``IMPORT_STAR`` opcode when creating a function directly from a code object "
"rather than via the compiler"
msgstr ""

#: ../pep-0558.rst:911
msgid ""
"This proposal deliberately *doesn't* formalise these semantics as is, since "
"they only make sense in terms of the historical evolution of the language "
"and the reference implementation, rather than being deliberately designed."
msgstr ""

#: ../pep-0558.rst:917
msgid "Proposing several additions to the stable C API/ABI"
msgstr ""

#: ../pep-0558.rst:919
msgid ""
"Historically, the CPython C API (and subsequently, the stable ABI) has "
"exposed only a single API function related to the Python ``locals`` builtin: "
"``PyEval_GetLocals()``. However, as it returns a borrowed reference, it is "
"not possible to adapt that interface directly to supporting the new "
"``locals()`` semantics proposed in this PEP."
msgstr ""

#: ../pep-0558.rst:925
msgid ""
"An earlier iteration of this PEP proposed a minimalist adaptation to the new "
"semantics: one C API function that behaved like the Python ``locals()`` "
"builtin, and another that behaved like the ``frame.f_locals`` descriptor "
"(creating and returning the write-through proxy if necessary)."
msgstr ""

#: ../pep-0558.rst:930
msgid ""
"The feedback [8]_ on that version of the C API was that it was too heavily "
"based on how the Python level semantics were implemented, and didn't account "
"for the behaviours that authors of C extensions were likely to *need*."
msgstr ""

#: ../pep-0558.rst:934
msgid ""
"The broader API now being proposed came from grouping the potential reasons "
"for wanting to access the Python ``locals()`` namespace from an extension "
"module into the following cases:"
msgstr ""

#: ../pep-0558.rst:938
msgid ""
"needing to exactly replicate the semantics of the Python level ``locals()`` "
"operation. This is the ``PyLocals_Get()`` API."
msgstr ""

#: ../pep-0558.rst:940
msgid ""
"needing to behave differently depending on whether writes to the result of "
"``PyLocals_Get()`` will be visible to Python code or not. This is handled by "
"the ``PyLocals_GetKind()`` query API."
msgstr ""

#: ../pep-0558.rst:943
msgid ""
"always wanting a mutable namespace that has been pre-populated from the "
"current Python ``locals()`` namespace, but *not* wanting any changes to be "
"visible to Python code. This is the ``PyLocals_GetCopy()`` API."
msgstr ""

#: ../pep-0558.rst:946
msgid ""
"always wanting a read-only view of the current locals namespace, without "
"incurring the runtime overhead of making a full copy each time. This isn't "
"readily offered for optimised frames due to the need to check whether names "
"are currently bound or not, so no specific API is being added to cover it."
msgstr ""

#: ../pep-0558.rst:951
msgid ""
"Historically, these kinds of checks and operations would only have been "
"possible if a Python implementation emulated the full CPython frame API. "
"With the proposed API, extension modules can instead ask more clearly for "
"the semantics that they actually need, giving Python implementations more "
"flexibility in how they provide those capabilities."
msgstr ""

#: ../pep-0558.rst:959
msgid "Comparison with PEP 667"
msgstr ""

#: ../pep-0558.rst:961
msgid ""
":pep:`667` offers a partially competing proposal for this PEP that suggests "
"it would be reasonable to eliminate the internal frame value cache on "
"optimised frames entirely."
msgstr ""

#: ../pep-0558.rst:965
msgid ""
"These changes were originally offered as amendments to :pep:`558`, and the "
"PEP author rejected them for three main reasons:"
msgstr ""

#: ../pep-0558.rst:968
msgid ""
"the initial claim that ``PyEval_GetLocals()`` was unfixable because it "
"returns a borrowed reference was simply false, as it is still working in "
"the :pep:`558` reference implementation. All that is required to keep it "
"working is to retain the internal frame value cache and design the fast "
"locals proxy in such a way that it is reasonably straightforward to keep the "
"cache up to date with changes in the frame state without incurring "
"significant runtime overhead when the cache isn't needed. Given that this "
"claim is false, the proposal to require that all code using the "
"``PyEval_GetLocals()`` API be rewritten to use a new API with different "
"refcounting semantics fails :pep:`387`'s requirement that API compatibility "
"breaks should have a large benefit to breakage ratio (since there's no "
"significant benefit gained from dropping the cache, no code breakage can be "
"justified). The only genuinely unfixable public API is "
"``PyFrame_LocalsToFast()`` (which is why both PEPs propose breaking that)."
msgstr ""

#: ../pep-0558.rst:981
msgid ""
"without some form of internal value cache, the API performance "
"characteristics of the fast locals proxy mapping become quite unintuitive. "
"``len(proxy)``, for example, becomes consistently O(n) in the number of "
"variables defined on the frame, as the proxy has to iterate over the entire "
"fast locals array to see which names are currently bound to values before it "
"can determine the answer. By contrast, maintaining an internal frame value "
"cache potentially allows proxies to largely be treated as normal "
"dictionaries from an algorithmic complexity point of view, with allowances "
"only needing to be made for the initial implicit O(n) cache refresh that "
"runs the first time an operation that relies on the cache being up to date "
"is executed."
msgstr ""

#: ../pep-0558.rst:991
msgid ""
"the claim that a cache-free implementation would be simpler is highly "
"suspect, as :pep:`667` includes only a pure Python sketch of a subset of a "
"mutable mapping implementation, rather than a full-fledged C implementation "
"of a new mapping type integrated with the underlying data storage for "
"optimised frames. :pep:`558`'s fast locals proxy implementation delegates "
"heavily to the frame value cache for the operations needed to fully "
"implement the mutable mapping API, allowing it to re-use the existing dict "
"implementations of the following operations:"
msgstr ""

#: ../pep-0558.rst:1000
msgid "``__len__``"
msgstr ""

#: ../pep-0558.rst:1001
msgid "``__str__``"
msgstr ""

#: ../pep-0558.rst:1002
msgid "``__or__`` (dict union)"
msgstr ""

#: ../pep-0558.rst:1003
msgid "``__iter__`` (allowing the ``dict_keyiterator`` type to be reused)"
msgstr ""

#: ../pep-0558.rst:1004
msgid ""
"``__reversed__`` (allowing the ``dict_reversekeyiterator`` type to be reused)"
msgstr ""

#: ../pep-0558.rst:1005
msgid "``keys()`` (allowing the ``dict_keys`` type to be reused)"
msgstr ""

#: ../pep-0558.rst:1006
msgid "``values()`` (allowing the ``dict_values`` type to be reused)"
msgstr ""

#: ../pep-0558.rst:1007
msgid "``items()`` (allowing the ``dict_items`` type to be reused)"
msgstr ""

#: ../pep-0558.rst:1008
msgid "``copy()``"
msgstr ""

#: ../pep-0558.rst:1009
msgid "``popitem()``"
msgstr ""

#: ../pep-0558.rst:1010
msgid "value comparison operations"
msgstr ""

#: ../pep-0558.rst:1012
msgid ""
"Of the three reasons, the first is the most important (since we need "
"compelling reasons to break API backwards compatibility, and we don't have "
"them)."
msgstr ""

#: ../pep-0558.rst:1015
msgid ""
"However, after reviewing :pep:`667`'s proposed Python level semantics, the "
"author of this PEP eventually agreed that they *would* be simpler for users "
"of the Python ``locals()`` API, so this distinction between the two PEPs has "
"been eliminated: regardless of which PEP and implementation is accepted, the "
"fast locals proxy object *always* provides a consistent view of the current "
"state of the local variables, even if this results in some operations "
"becoming O(n) that would be O(1) on a regular dictionary (specifically, "
"``len(proxy)`` becomes O(n), since it needs to check which names are "
"currently bound, and proxy mapping comparisons avoid relying on the length "
"check optimisation that allows differences in the number of stored keys to "
"be detected quickly for regular mappings)."
msgstr ""

#: ../pep-0558.rst:1027
msgid ""
"Due to the adoption of these non-standard performance characteristics in the "
"proxy implementation, the ``PyLocals_GetView()`` and "
"``PyFrame_GetLocalsView()`` C APIs were also removed from the proposal in "
"this PEP."
msgstr ""

#: ../pep-0558.rst:1031
msgid ""
"This leaves the only remaining points of distinction between the two PEPs as "
"specifically related to the C API:"
msgstr ""

#: ../pep-0558.rst:1034
msgid ""
":pep:`667` still proposes completely unnecessary C API breakage (the "
"programmatic deprecation and eventual removal of ``PyEval_GetLocals()``, "
"``PyFrame_FastToLocalsWithError()``, and ``PyFrame_FastToLocals()``) without "
"justification, when it is entirely possible to keep these working "
"indefinitely (and interoperably) given a suitably designed fast locals proxy "
"implementation"
msgstr ""

#: ../pep-0558.rst:1039
msgid ""
"the fast locals proxy handling of additional variables is defined in this "
"PEP in a way that is fully interoperable with the existing "
"``PyEval_GetLocals()`` API. In the proxy implementation proposed in :pep:"
"`667`, users of the new frame API will not see changes made to additional "
"variables by users of the old API, and changes made to additional variables "
"via the old API will be overwritten on subsequent calls to "
"``PyEval_GetLocals()``."
msgstr ""

#: ../pep-0558.rst:1045
msgid ""
"the ``PyLocals_Get()`` API in this PEP is called ``PyEval_Locals()`` in :pep:"
"`667`. This function name is a bit strange as it lacks a verb, making it "
"look more like a type name than a data access API."
msgstr ""

#: ../pep-0558.rst:1048
msgid ""
"this PEP adds ``PyLocals_GetCopy()`` and ``PyFrame_GetLocalsCopy()`` APIs to "
"allow extension modules to easily avoid incurring a double copy operation in "
"frames where ``PyLocals_Get()`` already makes a copy"
msgstr ""

#: ../pep-0558.rst:1051
msgid ""
"this PEP adds ``PyLocals_Kind``, ``PyLocals_GetKind()``, and "
"``PyFrame_GetLocalsKind()`` to allow extension modules to identify when code "
"is running at function scope without having to inspect non-portable frame "
"and code object APIs (without the proposed query API, the existing "
"equivalent to the new ``PyLocals_GetKind() == PyLocals_SHALLOW_COPY`` check "
"is to include the CPython internal frame API headers and check if "
"``_PyFrame_GetCode(PyEval_GetFrame())->co_flags & CO_OPTIMIZED`` is set)"
msgstr ""

#: ../pep-0558.rst:1059
msgid ""
"The Python pseudo-code below is based on the implementation sketch presented "
"in :pep:`667` as of the time of writing (2021-10-24). The differences that "
"provide the improved interoperability between the new fast locals proxy API "
"and the existing ``PyEval_GetLocals()`` API are noted in comments."
msgstr ""

#: ../pep-0558.rst:1064
msgid ""
"As in :pep:`667`, all attributes that start with an underscore are invisible "
"and cannot be accessed directly. They serve only to illustrate the proposed "
"design."
msgstr ""

#: ../pep-0558.rst:1067
msgid ""
"For simplicity (and as in :pep:`667`), the handling of module and class "
"level frames is omitted (they're much simpler, as ``_locals`` *is* the "
"execution namespace, so no translation is required)."
msgstr ""

#: ../pep-0558.rst:1228
msgid ""
"Note: the simplest way to convert the earlier iterations of the :pep:`558` "
"reference implementation into a preliminary implementation of the now "
"proposed semantics is to remove the ``frame_cache_updated`` checks in "
"affected operations, and instead always sync the frame cache in those "
"methods. Adopting that approach changes the algorithmic complexity of the "
"following operations as shown (where ``n`` is the number of local and cell "
"variables defined on the frame):"
msgstr ""

#: ../pep-0558.rst:1235
msgid "``__len__``: O(1) -> O(n)"
msgstr ""

#: ../pep-0558.rst:1236
msgid ""
"value comparison operations: no longer benefit from O(1) length check "
"shortcut"
msgstr ""

#: ../pep-0558.rst:1237
msgid "``__iter__``: O(1) -> O(n)"
msgstr ""

#: ../pep-0558.rst:1238
msgid "``__reversed__``: O(1) -> O(n)"
msgstr ""

#: ../pep-0558.rst:1239
msgid "``keys()``: O(1) -> O(n)"
msgstr ""

#: ../pep-0558.rst:1240
msgid "``values()``: O(1) -> O(n)"
msgstr ""

#: ../pep-0558.rst:1241
msgid "``items()``: O(1) -> O(n)"
msgstr ""

#: ../pep-0558.rst:1242
msgid "``popitem()``: O(1) -> O(n)"
msgstr ""

#: ../pep-0558.rst:1244
msgid ""
"The length check and value comparison operations have relatively limited "
"opportunities for improvement: without allowing usage of a potentially stale "
"cache, the only way to know how many variables are currently bound is to "
"iterate over all of them and check, and if the implementation is going to be "
"spending that many cycles on an operation anyway, it may as well spend it "
"updating the frame value cache and then consuming the result. These "
"operations are O(n) in both this PEP and in :pep:`667`. Customised "
"implementations could be provided that *are* faster than updating the frame "
"cache, but it's far from clear that the extra code complexity needed to "
"speed these operations up would be worthwhile when it only offers a linear "
"performance improvement rather than an algorithmic complexity improvement."
msgstr ""

#: ../pep-0558.rst:1256
msgid ""
"The O(1) nature of the other operations can be restored by adding "
"implementation code that doesn't rely on the value cache being up to date."
msgstr ""

#: ../pep-0558.rst:1259
msgid ""
"Keeping the iterator/iterable retrieval methods as O(1) will involve writing "
"custom replacements for the corresponding builtin dict helper types, just as "
"proposed in :pep:`667`. As illustrated above, the implementations would be "
"similar to the pseudo-code presented in :pep:`667`, but not identical (due "
"to the improved ``PyEval_GetLocals()`` interoperability offered by this PEP "
"affecting the way it stores extra variables)."
msgstr ""

#: ../pep-0558.rst:1266
msgid ""
"``popitem()`` can be improved from \"always O(n)\" to \"O(n) worst case\" by "
"creating a custom implementation that relies on the improved iteration APIs."
msgstr ""

#: ../pep-0558.rst:1269
msgid ""
"To ensure stale frame information is never presented in the Python fast "
"locals proxy API, these changes in the reference implementation will need to "
"be implemented before merging."
msgstr ""

#: ../pep-0558.rst:1273
msgid ""
"The current implementation at time of writing (2021-10-24) also still stores "
"a copy of the fast refs mapping on each frame rather than storing a single "
"instance on the underlying code object (as it still stores cell references "
"directly, rather than check for cells on each fast locals array access). "
"Fixing this would also be required before merging."
msgstr ""

#: ../pep-0558.rst:1281
msgid "Implementation"
msgstr ""

#: ../pep-0558.rst:1283
msgid ""
"The reference implementation update is in development as a draft pull "
"request on GitHub ([6]_)."
msgstr ""

#: ../pep-0558.rst:1288
msgid "Acknowledgements"
msgstr ""

#: ../pep-0558.rst:1290
msgid ""
"Thanks to Nathaniel J. Smith for proposing the write-through proxy idea in "
"[1]_ and pointing out some critical design flaws in earlier iterations of "
"the PEP that attempted to avoid introducing such a proxy."
msgstr ""

#: ../pep-0558.rst:1294
msgid ""
"Thanks to Steve Dower and Petr Viktorin for asking that more attention be "
"paid to the developer experience of the proposed C API additions [8]_ [13]_."
msgstr ""

#: ../pep-0558.rst:1297
msgid ""
"Thanks to Larry Hastings for the suggestion on how to use enums in the "
"stable ABI while ensuring that they safely support typecasting from "
"arbitrary integers."
msgstr ""

#: ../pep-0558.rst:1301
msgid ""
"Thanks to Mark Shannon for pushing for further simplification of the C level "
"API and semantics, as well as significant clarification of the PEP text (and "
"for restarting discussion on the PEP in early 2021 after a further year of "
"inactivity) [10]_ [11]_ [12]_. Mark's comments that were ultimately "
"published as :pep:`667` also directly resulted in several implementation "
"efficiency improvements that avoid incurring the cost of redundant O(n) "
"mapping refresh operations when the relevant mappings aren't used, as well "
"as the change to ensure that the state reported through the Python level "
"``f_locals`` API is never stale."
msgstr ""

#: ../pep-0558.rst:1312
msgid "References"
msgstr "Referências"

#: ../pep-0558.rst:1314
msgid ""
"`Broken local variable assignment given threads + trace hook + closure "
"<https://github.com/python/cpython/issues/74929>`_"
msgstr ""

#: ../pep-0558.rst:1317
msgid ""
"`Updating function local variables from pdb is unreliable <https://github."
"com/python/cpython/issues/5384)>`_"
msgstr ""

#: ../pep-0558.rst:1320
msgid ""
"`CPython's Python API for installing trace hooks <https://docs.python.org/"
"dev/library/sys.html#sys.settrace>`_"
msgstr ""

#: ../pep-0558.rst:1323
msgid ""
"`CPython's C API for installing trace hooks <https://docs.python.org/3/c-api/"
"init.html#c.PyEval_SetTrace>`_"
msgstr ""

#: ../pep-0558.rst:1326
msgid ""
"`PEP 558 reference implementation <https://github.com/python/cpython/"
"pull/3640/files>`_"
msgstr ""

#: ../pep-0558.rst:1329
msgid ""
"`Nathaniel's review of possible function level semantics for locals() "
"<https://mail.python.org/pipermail/python-dev/2019-May/157738.html>`_"
msgstr ""

#: ../pep-0558.rst:1332
msgid ""
"`Discussion of more intentionally designed C API enhancements <https://"
"discuss.python.org/t/pep-558-defined-semantics-for-locals/2936/3>`_"
msgstr ""

#: ../pep-0558.rst:1335
msgid ""
"`Disable automatic update of frame locals during tracing <https://github.com/"
"python/cpython/issues/86363>`_"
msgstr ""

#: ../pep-0558.rst:1338
msgid ""
"`python-dev thread: Resurrecting PEP 558 (Defined semantics for locals()) "
"<https://mail.python.org/archives/list/python-dev@python.org/thread/"
"TUQOEWQSCQZPUDV2UFFKQ3C3I4WGFPAJ/>`_"
msgstr ""

#: ../pep-0558.rst:1341
msgid ""
"`python-dev thread: Comments on PEP 558 <https://mail.python.org/archives/"
"list/python-dev@python.org/thread/A3UN4DGBCOB45STE6AQBITJFW6UZE43O/>`_"
msgstr ""

#: ../pep-0558.rst:1344
msgid ""
"`python-dev thread: More comments on PEP 558 <https://mail.python.org/"
"archives/list/python-dev@python.org/thread/7TKPMD5LHCBXGFUIMKDAUZELRH6EX76S/"
">`_"
msgstr ""

#: ../pep-0558.rst:1347
msgid ""
"`Petr Viktorin's suggestion to use an enum for PyLocals_Get's behaviour "
"<https://mail.python.org/archives/list/python-dev@python.org/message/"
"BTQUBHIVE766RPIWLORC5ZYRCRC4CEBL/>`_"
msgstr ""

#: ../pep-0558.rst:1351
msgid "Copyright"
msgstr "Copyright"

#: ../pep-0558.rst:1353
msgid ""
"This document is placed in the public domain or under the CC0-1.0-Universal "
"license, whichever is more permissive."
msgstr ""
